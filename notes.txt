2021_lc_coding
===================
1st round progress:
Every topic sorted by difficulty: easy to hard

Topics to cover:
-------------------
1. Binary Tree 
2. Binary Search
3. Array
4. bfs and queue
5. dfs and stack
6. Graph, topological sort 
7. HashMap
8. Strings
9. LinkedList
10. Dynamic Programming (many arrays and string problems here)
11. backtracking, recursion
12. Priority Queue
13. Greedy - nice to have

Practice by technique
-----------------------
-Sliding window
-2 pointers
-fast and slow pointers 
-DP
-interval type problems 
-cyclic sort?
-modified binary search 
-top-k elements

===================
===================
===================

1. Binary tree : 
---------------------
Tree:
			1
		2		3
	4		5
Depth First Traversals: 
(a) Inorder (Left, Root, Right) : 4 2 5 1 3 
(b) Preorder (Root, Left, Right) : 1 2 4 5 3 
(c) Postorder (Left, Right, Root) : 4 5 2 3 1
	
to remember:
	-lesson_binary-tree-postorder-traversal.java	-> there are mutiple ways to iterate using stack. see which one suites me.
	-balanced binary tree - 
		-top-down -check each node is balanced with helper method of height. O(n^2)
		-botttom up O(N) - needs node to store info - whether its balanced or not. build up on that.
			-even without storing info - bottom up is O(n)
			-visit eaach node once - Post order - call both children first.
			-this O(n) method to look for heigh difference called once only. store result in class var OR propagate in ret val.
		-THERE IS SUBTLE DIFFERENE BETWEEN THESE TWO IMPLEMENTATIONS THAT I DID NOT UNDERSTAND YET
		-same technique is used here for O(n):
			https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/e_diameter-of-binary-tree.java
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/e_lesson_subtree-of-another-tree.java
		-checking at each node is O(n^2)
		-converting tree to string - but order matters
		IMP - order matters. inorder will not work.
		ONLY preorder will work. its node by node comarision from top.
		ALSO: we need to count null leafs in string too, to avoid wrong comparisions, which gives false true.
        -to avoid returning true for example 2 above
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_binary-search-tree-iterator.java
		-next returns min elem - thus its in order retrival
		-we can use stack to store in-order sequence
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_count-univalue-subtrees.java
		-check for curr node as univalue 
			if(n.right !=null && n.right.val != n.val)
                return false;
            if(n.left !=null && n.left.val != n.val)
                return false;
		-no need to overcomlicate - one helper method traversal over whole tree is enough. no need to pass down n.val
 		-post order traversal/DFS - call l & r, then decide if parent is univalue.
		
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_find-duplicate-subtrees.java
		-convert tree in string (INCLUDING NULL NODES) 
		-only certain order will work - POST order 
		-ONLY add dplicate trees to result once
			-For people who are curious about why in-order doesn't work, here's a simple example:
			TreeA:
			0
			/
			0

			TreeB:
			0
			\
			0

			They both have same in-order serialization "#0#0#" if we just use "#" to represent null.

	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_flatten-binary-tree-to-linked-list.java
		TODO 
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_boundary-of-binary-tree.java
		-i think can be done with level order traversal.
		-store 1st in left and last in right lists.
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_inorder-successor-in-bst.java
		-successor will be right of x -> once u go right it can be n or n.left
		-keep going left and right as per BST, whenever go left (record n as return value first)
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_insufficient-nodes-in-root-to-leaf-paths.java
		-good one with regards to passing vals and returning node and making links
		Also, IMP to note that we do : DFS in POST order traversal way. ie, we go to leaf first, we call left and right first,
		then we can decide whether a parent is sufficient or not
		
		-pass down sum sofar
		-if sum < target at leaf, return null 
		-if n.l and n.r both becomes null, return null. -delete this node.
		
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_kth-smallest-element-in-a-bst.java
		-in-order tarversal and counter k (incement/decrement happens in-order, on current node. so counting does not start til lwe reach left most) - we dont have to worry about reaching left most elem and then start counting exclusively. that is part of "in order" processing.
		-that needs helper method (and class var for result ). cant be done in-place otherwise.
		-recursive - if we dont want class var - pass arr [counter,retVal]
		-iterative using stack, recursive usual. 
		
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_lowest-common-ancestor-of-a-binary-tree.java
		-first thought comes is helper method to find 2 elems under given node 
		-BUT we dodnt need that extra FIND method O(n^2)
		-//if root is p or q, that is LCA
        if( root == p || root == q || root == null)
            return root;
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_most-frequent-subtree-sum.java
		-dont need to calculate sum at each node separately
		-traverse tree once and record sums in map. map<sum,count>
		-sum = left+right+curr
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_serialize-and-deserialize-binary-tree.java
		Ser:
		pre-roder, # for null and ',' as delimiter
		
		Deser:
		Queue + preorder resursion
		Use Queue<> for deser, put all nodes in Q and just recreate tree in Pre-order fashion
		-Use Queue as FIFO, because thats the order in which we want to remove elems from list
		-IMP thing is deser is done in recursive fashion, just like pre-order, and elem taken from Queue every time in FIFO order

		-serialie - tree to array/string 
			-DFS pre-order traversal suits prob - bcoz that will make deser job easy. need to put null indicator in string 
		-desrialize - split string with delimiter ',' to get array 
			-use Queue , insert array in Queue - to get FIFO order
			-remove them one by one and just link them recursively (pre-order recursion)
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/h_binary-tree-maximum-path-sum.java
		-DFS/Post order traversal helps with O(n) path sum cal
		-imp to think which all paths are valid, and can possibly max . nodes can have -ve values 
		-maintain class level max 
		-helper: return currPathMaxSum - so that upper level can be max 
						-that is currPathMaxSum = n.val + Math.max(l,r);
				-for l and r, important to take 0 if return val is negative, so that currPath does not become less due to -ve children.
		
Continue from:
	102 Binary Tree Level Order Traversal
	and githun from:
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_trim-a-binary-search-tree.java


2. Binary search : 
---------------------
To remember-redo-practice:

Continue from:
	1099	Two Sum Less Than K

3. Array:
----------------------
github

Continue from:m_set-matrix-zeroes.java
	[hard remaining]
TODO:
https://leetcode.com/problems/top-k-frequent-elements/ - add this to github
	
to remember:
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_daily-temperatures.java	-> stack the indices rather than temp vals, because we need index diff. -> start from end -> monotonic stack.
	
	4 sum:
		-For each elem [i], solve k-1 problem recursively, at k=2, solve 2sum problem
			-2sum loop/sweep shud not end as soon as we find pair, because we need to find ALL pairs to continue till (l<r)
		
		-Time complexity is O(N^(K-1)).
		-generalize as :
		private List<List<Integer>> kSum(int[] nums, int target, int k, int leftBegin)
		-run loop till it becomes 2 sum prob OR k=2
			-that k loop looks like :
			for (int i = left; i < len - (k - 1); i++) {
                //use current number to reduce ksum into k-1sum
				//arr[i] will be part of sol list
                List<List<Integer>> curr = kSum(nums, target - nums[i], k-1, i+1);
				=> then add arr[i] to each lists returned
				
		-duplicate check has to be done in 2 sum as well as other loop too 
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_3sum-closest.java
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_3sum-smaller.java
		-tricky - there is more than just counting at each 2 sum sweep.
		-at any given 2sum sweep : if(localsum<target)
			-we need to count all combinations keeping "low or l". 
			x,l,r
			x,l,r-1 
			x,l,r-2 etc
		-that will not be covered in next iteration. bcoz if localsum<target, we will move to l++
			
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_find-all-duplicates-in-an-array.java
		-nums are 1 to n -> convert that to index/bucket as arr[i]-1
		-every time we see num, we do x * -1
		-so if num seen only once, it will be -ve 
		-second loop can catch this 
		-use Math.abs while calculting index, because num can be -ve as done by us only 
		
	cherry pick algo:
	https://leetcode.com/problems/remove-duplicates-from-sorted-array/ - remember the basic trick, write ptr, read ptr. no need to run fast pointer all at once
		-write/good ptr. ptr to track index to unique elems. (slow, write location) => this of this ptr as if we had new empty array where we store desired elems for return. ptr in that array where we can write new elem.
		-iterator ptr (fast, read ptr)
		=>similar qns: (in place array operations - single iteration solutions)
			https://leetcode.com/problems/remove-element/
			https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
			
		-write ptr and iterator will diverge as we start seeing duplicates to be removed.
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sliding-window_grumpy-bookstore-owner.java
	
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sort-colors.java
		-ptr to color 0, at 0
		-ptr to color 2, at len-1
		-iterate over array using i => while(i<=p2)
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_subarray-sum-equals-k.java
		-Sliding window cannot be used, because array contains negative number
		-Its "prefix sum" problem.
		-Solution 1. Brute force. We just need two loops (i, j) and test if SUM[i, j] = k. Time complexity O(n^2), Space complexity O(1). 
		-Solution 2. From solution 1, we know the key to solve this problem is SUM[i, j]. 
			-we need faster way to find SUM[i, j]
			-So if we know SUM[0, i] and SUM[0, j], then we can easily get SUM[i, j]
				SUM[i, j] = SUM[0, i] - SUM[0, j]
			
		-since we are asked to count HOW many times we see the sum, we need to store the Map<sumseen_sofar, count>
		-keep recording sum so far in map.
			-if we have seen  ( SUM[0, i] - target ) -> add this to answer.
			
	m_set-matrix-zeroes 
		-A straight forward solution using O(mn) space is probably a bad idea. track 0 converted elems/visited elems. so that we dont consider them original 0s.
		-improvement: only track col and row nums which needs to be zeroed. PAss1: record these rows and cols. PAss2: zero down those rows and cols. 2*O(mn)
		- work on memory efficient soln
			-> use this soln: https://leetcode.com/problems/set-matrix-zeroes/discuss/26008/My-AC-java-O(1)-solution-(easy-to-read)
			-They are using the first row and column as a memory to keep track of all the 0's in the entire matrix.
			-only problem with that is : if 0th row or col is 0. - >becaues if so : if 0throw is 0, we need to make 0th col zero as well. as same for cols 
			-so use 2 more flags to indicate if fr or fc is zero.
			
	product-of-array-except-self -> need to do without division. -> realize that product except self = product(on left) + product (right)
		-> that can be achieved without creating extra arrays for left and right.
		->use same arr for both loops. and that will be our ans 
		->iterate left to right skiping sefl
		->iterate right to left skipping self. both times record res in same array. that will be ans
	
	m_interval-list-intersections
		-iterate over both together 
		-find out if there is intersection 
		-then decide which arr to proceed 
	
	m_prison-cells-after-n-days
		-in-place modification of arr not possible, coz we need orig values of cell till end.
		-so create new arr to store the result. create hlper method to do this and return new arr 
		Optimization:
		-there is possibility of cycles if we change values N times.
		-in that case we can store result in hashSet and see if we have seen this before. if so, dont continue N days loop. its cyclic 
		-record at which iteration we got cycle 
			if(hasCycle){
				N%=cycle;
				for(int i=0;i<N;i++){
					cells = nextDay(cells);
				}   
			}
	
	https://leetcode.com/problems/rectangle-area/
		-calc both rectangle areas (x2-x1) * (y2-y1)
		-find overlap points
			-find overlap points and apply formula like above 
	
	m_trick_gas_station
		-tricky yet simple algebra
		-we dont have to try each position exclusively, single iteration is enough 
		-gas[] - gas_available
		-cost[] -gas_needed ( cost or dist )
		-track gasAvailable after each node 
		-if gasAvailable  -ve, that node is not answer 
		-at end if gas_needed+gas_available > 0 we are in surplus and can make it.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sliding-window_grumpy-bookstore-owner.java
		-sliding window technique !
		-count normal sum of whole array.
		-now slide window of sixe X (counting/adding 1's to satisfied custs)
		-now keep sliding till end, and recor max every time we slide 
		==> or just dont count sum in advance and do it?
			-count satisfied custs while iterating
			-keep track of max in window and keep sliding 
		
4. 	BFS and queue:

There are 2 aspects to BFS.
-some problems, first figure out which all nodes need bfs and add them in queue.
-some problems, just start with one node in queue as starting point.

-level order traversal.
-iterate thru all neighbors?

Continue from: https://leetcode.com/problems/perfect-squares/

to remember:
	https://leetcode.com/problems/evaluate-division/solution/
	https://leetcode.com/problems/the-maze/solution/
		-DFS is more natural here. But BFS has advantage of less heap space.
		-need to keep track of visited nodes 
		-for(4 directions) {
			newpos = roll()
			if(dfs(newPos))
				return true;
		}
		
		BFS
		-add start pt in Q
		-poll Q 
		-add to visited 
		-check if its dest
		for(4 dirs) {
			newpos = roll(dir);
			if(not visited newPos)
				Q.add(newpos)
				
		}
		
	https://leetcode.com/problems/rotting-oranges/
	-first need to cound good oranges, because its possible that whole sweep cannot reach all good oranges, so we need to return -1 in that case.
	-we dont need to store visited nodes.
	-i think because we already recorded all rotten oranges first.
		-we only add nodes to Q once, 
		1. initially
		2. when we convert them to rotten in loop 
	
5. HashMaps
Continue from: github
	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_insert-delete-getrandom-o1.java
to remember:
	-log rate limiter - study various approaches IMP
		-we need LAST 10 sec window, 10 slots. queue, array, circular buffer whatever u think of.
		-Also, we need Set for each slot, so that we know whether incoming log was printed in any of last 10 secs
		a. figure out slot - based on given timestamp. clear old slot if not same. clear old set as well in that case
		b. check if msg was printed in last 10 secs. go thru each slot (see if slot time < 10 secs) and see if present in any of the sets.
		
	https://leetcode.com/problems/next-greater-element-i/
	https://leetcode.com/problems/isomorphic-strings/
		-go char by char 
		-need 2 maps. a to b char mapping and b to a chars mapping. because both sides can break the mapping done earlier.
		-if entry does not exist add (a to b) and (b to a)
		-if either side map entries dont match - false.
		todo: 2 arr technique. same as hashmap, we just use arr as map.
		
	https://leetcode.com/problems/find-duplicate-subtrees/
		representation of tree(segment) can be in terms os String with all nodes in some order (post order here is must)
		-also include null nodes
		-ONLY add dplicate trees to result once
		-we use HashMap<String,Integer> , because we want to know how many times we have seen current path, so that we dont add it to result more than once
		-For people who are curious about why in-order doesn't work, here's a simple example:
			TreeA:
			0
			/
			0

			TreeB:
			0
			\
			0
			They both have same in-order serialization "#0#0#" if we just use "#" to represent null.

	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_group-shifted-strings.java --> key forming math
		-use ascii diff between 2 chars: for 1st char, val = 0
			acf = 0->2->3, and pru = 0->2->3.
			
		-az, ba
			-where az = 0->25 and ba = 0->-1. When it goes negative, 
			-just make it positive(rotate or mod equivalent) by adding 26. So it becomes, ba = 0->25, which forms same group
		[(charA-charB) + 26] % 26 
			-we do +26 beause we need circular progressing index. az if we rotate this, it becomes za, so our key should do that.
			
	https://leetcode.com/problems/time-based-key-value-store/
		-all we need is :
		HashMap<String,TreeMap<Integer,String>> map;
			-for each keyString - we need to store : at what timestmap, what string val we have.
				-if we dont have any at give timestamp, we look for smaller timestamp valString.
			-we need treeMap, reverse sorted by time. latest time first.
			
	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_insert-delete-getrandom-o1.java
		-need ArrayList as main data store. easier for getRandom, as random is based on index.
		-Map<int, itsIndexInList>
			-how to avoid shifting the whole arraylist while remove in middle of list? there is another problem in shiftin, its we stored indices of nums in map, that will change as well!
			-swap elem-x with last elem. and remove last elem. map has to be updated accordigly.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_lesson_find-and-replace-pattern.java
		-same logic as isomorphic strings.
		
6. Binary Search 
continue from:
	h_median-of-two-sorted-arrays.java
	-from : m_lesson_search-a-2d-matrix-ii.java
	
to remember:
	-Note: search in binary tree can be done iteratively. go left or right till reach null leaf 
	m_Search_for_a_Range.java 
		-> use template-1 (l<=r) and record target index each time. Sicne we are looking for exact match - template1 is suitable.
		- template 2 (l<r) has issues - might get into endless loop.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/e_sqrtx.java
		-return closest decimal is perfect square is not available
		-use division to overcome overflow, instead of long. -> because truncation is allowed as per question.
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/e_valid-perfect-square.java - use long instead of division technique. because division will lead to false true. (2 = 5/2 - but its not perfect square)
		-imp to check if its perfect square at end of loop too.
		
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-first-and-last-position-of-element-in-sorted-array.java
		-dont use while(l<r) template - problem narrow downing the end
		-use while(l<=r) template 
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-k-closest-elements.java - template III mid+k widnow
		if(Math.abs(arr[mid]-x) > Math.abs(arr[mid+k]-x)){
		-we are comparing mid and mid+k to decide which side to go.
			
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_search-a-2d-matrix-ii.java - TODO binary search way. currently doing narrowing down method, beginning bottom left corner.
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-minimum-in-rotated-sorted-array.java
		-what to do if there are duplicates?
		-if(nums[mid]==nums[right])
			reight--;//to skip dups
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_search-in-rotated-sorted-array.java
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_kth-largest-element-in-an-array.java
		-use quick sorting. quick sort partition step gives small nums on left of pivot selected.
		-so turn kth largest prob into len-kth smallest elem. k2 = len-k
		-partition method is recursive till we find k2 elems in left partition
			-if l> r return IntMAX
			-for partition, maintain writePtr = l, 
			-after loop, swap one more time 
			-if nums left of pivot == k2 return that index. 
			-if nums left of pivot > k2 -> go left
			else go right 
	
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_floor-function-sorted-array.java
		--normal bianry search function : if val not found, it ends up at smaller closest !
		-so use template 1, and keep recording val if its <x, at end of loop that will be our answer.
		-template 2 also popssible

todo:
	h_median-of-two-sorted-arrays.java	
	https://leetcode.com/problems/time-based-key-value-store/
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_floor-function-sorted-array.java
		--normal bianry search function : if val not found, it ends up at smaller closest !
		-so use template 1, and return nums[start] after loop.
		-template 2 also popssible
	m_lesson_online-election.java
	
todo:
Some of the Binary Search based Interval Problems :)
57. Insert Interval - https://leetcode.com/problems/insert-interval/
436. Find Right Interval - https://leetcode.com/problems/find-right-interval/
729. My Calendar I - https://leetcode.com/problems/my-calendar-i/
1235. Maximum Profit in Job Scheduling - https://leetcode.com/problems/maximum-profit-in-job-scheduling/
2054. Two Best Non-Overlapping Events - https://leetcode.com/problems/two-best-non-overlapping-events/

IMP note:
===================
-template2 - given that arr is ascendin sirted, and we do l = m+1 when x<target
	Obs1 . what index does template-2 settle at? what is end val of l - when elem not found?
		->it settles on upper (closest) side of target!
			-so if target was not the max num of arr, it WILL settle on last index of arr. !
		->that means normal template 2 serves as "CEILING" function. 
	
	Obs2
		-template2 will always return a "VALID" index. (0 to len-1)
	
	Obs3
		-template1 may return a "INVALID" index. (0 to "len") - when num is bigger than upper bound
	
	Obs4
		-template 1 also settles on the num (closest Bigger) than target, if target not in arr.
		-so it serves as "CEILING" function (except last elem, for which check is needed)
		
	-sometimes, when we want to derive a fitting index (may be elem?), we need to be careful of 'r'
	-normally r = arr.len-1 
	but if we want to settle to correct index - we may want to set r = arr.len
		Example:
		https://leetcode.com/problems/search-insert-position/
			-template1 works very good here. BUT if we want to use template2, we need to set r = arr.len 
	-Think another problem: 
		1. return index of elem smaller than target 
		2. return index of elem bigger than target 
		3. floor function 
	
	-Trick on template2 
		-to get floor functionality out of template 2:
			set l = 1 and r = len
			-because we know it will settle down on celingin elem 

TODO
Floor-function:
	-there are only 3 possibilities
		-target below 0
		-target above arr.len 
		-target index inside arr 
		
	-its easier to get corner cases right away before doing loop.
        // If last element is smaller than x
        if (x >= arr[r])
            return r;
		if(x <arr[0])
			return -1;
			
Floor and Celining:


			
7. DFS
continue from:
	TODO: hards
	
to remember:
	m_basic-calculator-ii.java -> 
		-little not intuitive. keep putting + and - operands (nums created so far) in stack. * and / calculate in run time.
		=>Addition (+) or Subtraction (-): We must evaluate the expression later based on the next operation. So, we must store the currentNumber to be used later. Let's push the currentNumber in the Stack.
		=>Multiplication (*) or Division (/): Pop the top values from the stack and evaluate the current expression. Push the evaluated value back to the stack.
		-buffer currentNum AND last sign seen (because after sign, we need RHS to evaluate expression. so when we are after RHS(whcih is next sign or end of string) ,we evaluate last sign )
		-if char is digit, keep forming currentNumber 
		-if char is not digit, and its not space, -> operate. and reset currentNumber = 0 at end
		-we are not forming final result in iteration, we keep putting each result back in stack . at the end, we iterate over stack and add them all 
		
	m_copy-list-with-random-pointer.java 
		-> need to use HashMap<origNode,newNode> as visited record, instead of set, because we need to retrieve new node to reuse (from given visited node)
	
	m_decode-string.java 
		-maintain 2 stacks, one for nums , one for string 
		-> when encounter [, we need to push stringSoFar on stack -> because there can be multiple/nested layers (just like num/count nesting), we we wont be able to store it directly in final result
		->k[string k[string k[string]
		-when see ], calculate string (suing both stack pop vals)
		-at the end result with be last string formed
	
	m_exclusive-time-of-functions.java -> see as time intervals. Since its logs, its already in chronological order/sorted, so no need to sort by start time. -> now imp to realize use of stack. We dont use PQ here like interval problems (because already sorted by start time). push started tasks in stack (like actual call stack !) -> stack<taskId> only. calculate exclusive time during iteration itself.
		-> when see end log, pop.
		->result can be array and taskId serves as index. so no hashmap required
		->when end log comes, taskid will alway match to top of stack. ()
	m_flatten-nested-list-iterator.java 
		-> imp to realize the recursive nature. since its rec, we can use stack. BUT we want them in FIFO order, so push items to stack with reverse loop on list given
		-> during constructore, put curernt list as is on stack (no deep flattening, that will be done while hasNext call)
		-> hasNext - if item is list, reuse the "insert" method, to flatten/insert that list on stack (just 1 list)
			-while(!st.isEmpty()) { //flatten each elem of curr stack , BUT if we see int , we stop} //we have to do this till st is empty, because there is possibility of nested lists without seeing any int. also list can be empty 
			
		->next - just pop item.
		-> imp: next will not be called without calling hsNext
	
		-->Queue based iterative solution:
		--> but downside is, we create new storage for entire nestedList again, rather that going thru given input.

	m_lesson_all-paths-from-source-to-target.java -> realize that we need to backtrack (remove curr neighbor from path) before next iteration to other neighbor. (after recursive dfs call)
Note: dfs helper function normally will not return anything, its just dfs sweeper. result will be recorded in some class var.

	m_lesson_path-sum-iii.java -> see each root to leaf path as array, and we are looking for subarray that sums to target. for that we use "prefix-sum" technique. so thats what we will do.
		-> imp : consider two nodes having same num (also -ve nums are allowed), so our prefix sum map will need <sumSoFar, frequency>
	
	
	m_word-search.java -> dfs+backtracking -> again exhaustive dfs. whenever there is exhaustive dfs, dont forget to clear/backtrack visited node if word not found here. if the path does not lead to a solution, we then revert the change (i.e. backtracking) and try another path.
		-> also this dfs helper needs to return boolena for whether word found or not. -> so need to OR all dfs directions.
		-> time complexity: Time Complexity: O(N. 3^L) where N is the number of cells in the board and L is the length of the word to be matched.
	
	
8. Strings 
continue from:
	m_trick_multiply-strings
	
to remember:
	e_lesson_most-common-word.java -> good practice of string iteration by chars, and corner cases. -> character.isLetter and stringbuilder are enough to make word. we dont need start and end pointer to make word.
		how do we iterate char by char and derive each word?
		a. use two ptrs -> start and end
		b. use stringbuilder, build it up to one word, usinng just one ptr. after loop - check if strinbuilder is non empty (when whole string is 1 word or also for last word)
		
	longest-common-prefix - > there are many ways to solve. ->pick 1st string, and compare char by char in rest of strings. stop when dont match and return prefix.
		-> divide and conquer, binary search are possible.
		-> find min and max strings, then compare..
	reorder-data-in-log-files.java -> use String x = a.substring(a.indexOf(' ')+1,a.length());		
		-> also note: comparator for pq -> strA.compareTo(strB)
	reverse-words-in-a-string-iii -> how do we iterate char by char and derive each word?
		a. use two ptrs -> start and end -> in place operations. no extra space needed.
		b. use stringbuilder, build it up to one word, usinng just one ptr. - after loop - check if strinbuilder is non empty (when whole string is 1 word or also for last word)
	e_strstr.java -> brute force match at every char position in bigger string.
	e_trick-greatest-common-divisor-of-strings.java -> GCD for string is the biggest common substring. so we need to keep cutting substrings from begin point until we cant.
		-> if one string is empty, other is the answer to return.
	e_unique-email-addresse -> to replace occurences of . in string:  id = id.replaceAll("\\.","");   //remember this utility and \\ for before .
	m_atoi.java -> there are corner cases to be covered:
		0. remove spaces from front and back - trim
		1. sign in front - may or may not be present
		2. Integer overflow min and max. Store temp result on "long". if temp result = max or min, return max of min, because its overflow.
		3. look for non digit chars. once encounter, break/stop
		-> use long to store intermediate result to check int overflow. converting string to int, char/digit by digit. 
	m_group-shifted-strings ->
		key += String.format("%2d", (s.charAt(i) - s.charAt(i-1) + 26) % 26);//positive Difference from the previous char.
		->circular shifted strs in same group
		->TODO need to understand the logic ((a-z)+26)%26 -> %26 so that we get circular position. +26 because we want +ve num in case of "az"
		
	m_lesson_compare-version-numbers.java -> 
		-need to consider various corner cases: Following are equal:
			1.0 and 1.000
			1.0 and 1.0.0
			1.01 and 1.001
		->split string by dots
		->create utility to convert string to int. ->skip prefix zeros
		-key to make soln easy-for diff length, we can use 0 for whichever finished. ===> IMP TRICK FOR ANY 2 ARR OPERATIONS
	m_lesson_longest-substring-with-at-most-two-distinct-characters.java 
		-> need to store HashMap<char, latestIndex> -> we store latest/last index because, if we were to remove that char, we need to remove till right most occurence of that char. we cannot just remove left most char and be sure that that char is not present in window anuymore. eg abcccbdddddd
		
		-> only use of left ptr is to cal len of substring. not for remove char from left side.
		-> but leftmost cant be tracked with ptr, each time need to go over map and find leftMost char to remove from sliding window
		->when window/map size ==3, FIND THE LEFTMOST CHAR/INDEX TO BE REMOVED, BY GOING THEU MAP VALUES or just call Collections.min(map.values);
		-> note: it is possible to solve with lft and right ptrs and slide from left one by one and map<char,freq>, but not as straight as above.
	m_lesson_partition-labels.java ->
		it sounds complicated, recursive and dp problem, but its not !
		->2 pass solution:
        -Record the last occurence of each letter in map
        -Second pass can be done in way that we will get max partitions.
			-Keep current interval window marked by begin and end pointers
            -keeptrack of furthest most index of occurence for any letter in current interval/window. that var is our "end" ptr of window
            -if that is = i, we dont have anymore repeating in future, so partition window ends here. add it to result.
                Note: We END it here rather than including more unique chars because we want as many unique intervals as we can.
	m_longest-substring-without-repeating-characters.java 
		-> set is enough with sliding window. map not required here.
		-> when we slide from left, we dont increment the right ptr. because duplicate might just be right -1 ! eg: abcdee -> when we sit at right = 2nd e.
	m_palindromic-substrings.java -> 
		-count palindrom from odd center. (i)
		-count palindrom from even center. (i,i+1)
			-to cehck palindrome, run loop to expand from center.
		-do this for every i from 0 to len 
	m_reverseWords.java
		->trim both ends first 
		->now reverse the string then reverse each word. 
		-> wo do this to avoid extra space. if we dont reverse, we will store each word in array/stack. ->then build string with words in reverse order.
	m_trick_fraction-to-recurring-decimal.java
		-explained well by diagram in leetcode.
		-> main trick : if remainder starts repeating, we know its repeating and finish
		-> we need to know where the repeating part starts. index of each digit in fraction -> do it by hashMap<Long, index>
		-> we use Long for all calculations to cover int overflows 
		-> how do we keep reducing remainder? -> this is just plain division operation.
			long remainder = dividend % divisor;
			-> while(ramainder ! = 0){
				ramainder *= 10; --> whi mult by 10? that is how we proceed manunal division
				remainder %= divisor;
			}

	https://github.com/krutikpatel/leetcode2019/blob/master/strings/m_trick_multiply-strings.java
		-> compute products from each pair of digits from num1 and num2. 
		-> carry each element over. (arr will have nums 1 to 99 possible)
		-> output the solution.

9. Priority Queue - Interval types
Note:
if we need top -k elem 
	-we can do it with PQ size of k+1
	-for max, make min heap. add k+1 elems. if (pq size >k)->poll top elem.
		-this will end up in top k elems in pq.
		
todo:
	lesson_car-pooling.java
	task-scheduler.java
	
to remember:
	m_exclusive-time-of-functions.java 
		-> see as time intervals. Since its logs, its already in chronological order/sorted, so no need to sort by start time using PQ. 
		-> now imp to realize use of stack. We dont use PQ here like interval problems (because already sorted by start time). 
		->push started tasks in stack (like actual call stack !) 
			-> maintain stack<taskId> only. calculate exclusive time during iteration itself. use lastStartedTime to track prev start-timestamp
			-> when see end log, pop.
			->result can be array and taskId serves as index. so no hashmap required
			->when end log comes, taskid will alway match to top of stack. (first to end will be last to start - because its single threaded - V Imp - this is why we are able to use stack only)
	
	m_interval-list-intersections.java 
		->iterate with ptrs over both arrays together
		->overlap interval = [biggerStart,smallerEnd]
			->then which ptr to move ?
			move minEnd - thats the one which ends first, because other one might still intersect with next
		->since we are looking for overlap - nothing to do after loop exits
	
	m_meeting-rooms-ii.java
		->first sort intervals by start time.
		->use pq to store intervals - sort by end time - min heap - so we get roo first to finish.
			-actually we are only using end time from intervals in pq. so we only need pq<Integer>
		->if new start-time >= end-time from pq, re-use room
			->remove this pq top interval - room can be reused.
		->add new interval to pq.

	merge-intervals.java
		->sort them by start time 
		->iterate and merge
			->while its possible to add loop inside to merge till we can with curr elem. since we are not doing it in place - not modifying given array, returning new arr, we wont do it. 
			->thats not good idea, complicates loop
			->just merge one at a time. while keeping track of prev interval.
		[what if there were 2 lists to merge?]
		
	reorganize-string.java
		->map chars by count.
		->store int[charASCII, count] in pq -> max heap
		->now keep polling pq and interleave.
			->poll one, append in stringBuilder, reduce its count 
			->that is now prev
			-> use prev to keep track of char we just used in result in last iteration. -> because we need to add it back to pq if count >0
			aab 
				1->remove a from pq 
				2->next time remove b, 
				-> prev is a. put back in pq.
				->add b in result -> ab -> then prev becomes b 
				3->prev = b but count == 0, so dont add in pq.
					->add a to result -> aba 
			->so, if (pq is empty && prev count > 0	) -> eg: aaab
				->then we can find elems/char to separate all "a". so return false 
		
		-given pq: aaaabbn
			think what wud u do. remove a, then use b, then  use a again
			
	merge-k-sorted-lists.java
		->add 1st elem of all lists to pq (min sorted)
		->now link nodes to create new ordered/merged list
		->now till pq is empty
			->poll, 
			->make linkage -> curr.next = polled -> curr = curr.next 
			->add curr's/polled's list's next elem to pq (if non null ie, list has not ended)

	car-pooling https://github.com/krutikpatel/leetcode2019/blob/master/priority_queue/lesson_car-pooling.java
		probably better to look at non pq based solutions..
		-sort arr by start time.
		-treat start and end time as intervals 
			-start point = capacity+
			-end point = capacity-
		-we will maintain pq - sorted by end time.
		->when we see end time 
		
10. Graph 
notes under graph directory.
	-https://leetcode.com/problems/evaluate-division/
		-As one can see, we just transform the problem into a path searching problem in a graph.
		** More precisely, we can reinterpret the problem as "given two nodes, we are asked to check if there exists a path between them. If so, we should return the cumulative products along the path as the result. **
		-Imagine a/b = k as a link between node a and b, the weight from a to b is k, the reverse link is 1/k. Query is to find a path between two nodes.
		-for each node, we need neighbors and weight of that edge. Best way to do that is Map<neightboer,weigth> for each node
		-adj list with weights : Map<String, Map<String, Double>> adj
		-need to track visited nodes in DFS to catch loop. 
		-return -1 for no sol and loops.
	
	-https://leetcode.com/problems/all-paths-from-source-to-target/
		-DFS + backtrack
		-all paths means backtrack
		-it is given that graph is "acyclic" - so we dont need to maintain "visited" map 
		
continue from:
todo:
	-Hard ones
	
11. Sliding window:

to remember:
	->https://designgurus.org/path-player?courseid=grokking-the-coding-interview&unit=grokking-the-coding-interview_1628541055153_6Unit	
		-we dont have to worry about consecutiveness of window for pattern anagram/permutation
		-the matchCharCount combined with checking at each char, will take care of it.
		-so, just store <char,count> map for pattern, and decrement,increment it as we slide char by char.
		

12. Backtracking/recursion
-starting from leetcode 

	https://leetcode.com/problems/restore-ip-addresses/
		-maintain beginIndex and segmentCount - to return once done 
		-each time - we create segment with 1,2 or 3 digits and make recursive calls.
		-imp - the segment has to be valid(0 to 255), so validate before recursive call.
		-remove dot from last segment end.
	
	n-queens 
		-how to mark/access diags \ and / to see if its valid?
		boolean[] d1,d2 //len 2*n 
		int id1 = col - row + n;    // this is / diagonal for that point. col -row can be negative, so if we want to store it in array, 
                                        // we have to make it +ve offset by adding n to each
        int id2 = col + row;        // this is \ diagonal for that point
        OR-use Set<Integer>
			and
			int currDiagonal = row - col;
            int currAntiDiagonal = row + col;			
	
	sudoku
		-recursive method params are not fancy, just board
		private boolean solve(char[][] board){
			-all param looping inside method.
			for rows 
				for cols 
					for num1to 9
		-isValid method for puttin num at particular cell 
			-validity for that 3x3 block
			int rr = 3 * (row/3);
			int cc = 3 * (col/3);
	
	https://leetcode.com/problems/remove-invalid-parentheses/
		-BFS:
		-Since optimal soluion is asked, we should think of BFS.
			-meaning : parallelly explore removing one parantheses from each position, and keep doing that at each level
			-strings resulting by removing one paranthesis from each positions, becomes my neoghbors for next level BFS
		-maintain Set of visited strings 
			// generate all possible states, as next BFS level
			for (int i = 0; i < s.length(); i++) {
			  // ignore non-paranthesis chars
			  if (s.charAt(i) != '(' && s.charAt(i) != ')') continue;
			
			  String t = s.substring(0, i) + s.substring(i + 1);
			
			  if (!visited.contains(t)) {
				// for each state, if it's not visited, add it to the queue
				queue.add(t);
				visited.add(t);
			  }
			}
		-trick for validity : 
			if ( count++
			if ) count--
			if(count <0) -> invalid/false
		-no need to worry about char inbetween. parantheses validity will be same regardless of chars between them.
	
	word-break-ii 
		https://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS
		-we dont have to go char by char from given string and do recursion. rather,
		start from word in give dict arr, and see if give string "starts with" that word.
			-if so, make recursive call from there.
			-after return, add 1st word in front of return list to form answer string 
		
		(see in comment section in above link: its still easy to go char by char, we dont have to pass charIndex in recursive call.)
		
		-BUT, brute force DFS exceeds time. So we need to memoize.
			-what to memo? - if we have answer for given (prefix) string 
			HashMap<String, List<String> answers>
			
todo:
	
	https://leetcode.com/problems/remove-invalid-parentheses/
		-DFS+trie
		-need of trie comes from the fact that we need to know that we have a prefix match so that we can keep continue down this route. otherwise waste of runtime.
		
	word-search 2
	word ladder 2
		
continue from:
	
	
Note:
-MIMP: think recursive prob as solving subproblem. eg: 
	-Permutation: abc -> a + permutations of (bc)
	-subset: abc -> a + subsets of (bc)
	-so we solve subproblem first, as a result output will be in that order.
	-combinaitions of 1,2,3,4 -> take 1 (add 1 to sofar) and solve problem recursively from 2
	
-permutations output order for swap based recursive algo
	Input: nums = [1,2,3]
	Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
	
-duplicates: 
	-the first call at any level is i=beginIndex: so we need to allow i=beginIndex but avoid duplicates.
		so: if(i!=beginIndex && twoNumsAreStillsame)
	-we normally sort entries so that duplicates are together. we might get away without sorting for permutation because of swap, but for subsets we need to.

-subsets output order will be:
	Input: nums = [1,2,2]
	Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
	if(soFar.size() > 0){
		ret.add(new ArrayList(soFar));//we make new cipy of list to add in result because this copy will keep modifying.
	}

-https://leetcode.com/problems/word-search/solution/
	-combintion of DFS and backtracking - super problem.
	-backtracking is during each DFS for visited nodes.
	-NOTE: visited boolean[][] does not have to be created fresh for every DFS starting point x,y. since we are backtracking and clearing flags, same map can be reused as is dugin next x,y DFS check.


13. DP
	https://github.com/krutikpatel/leetcode2019/blob/master/dynamic_programming/e_best-time-to-buy-and-sell-stock.java
		-track minSoFar
		-if currElem > minSofar
			-track max diff/profit
	
	https://github.com/krutikpatel/leetcode2019/blob/master/dynamic_programming/e_maximum-subarray.java
		-simpler than the instinct of making it complicated. -no recursion no complicated memo.
		-its like sliding window problem acctually - But its not totally
		-this is a popular problem that can be solved using an algorithm called Kadane's Algorithm.
		-The difficult part of this problem is figuring out when a negative number is "worth" keeping in a subarray.
			-We need a general way to figure out when a part of the array is worth keeping.
			-any subarray whose sum is positive is worth keeping.
		-Ans: we don't actually need to build the subarray, we can just keep an integer variable current_subarray and add the values of each element there. When it becomes negative, we reset it to 0 (an empty array).
			-track max 
			-keep adding till sum is +ve 
			-if it becomes -ve, discard all. 
					if(sumSoFar < 0) {
						sumSoFar = nums[i];
					} else {
						sumSoFar = sumSoFar+nums[i];
					}
					maxSum = Math.max(maxSum, sumSoFar); 
			
		-Same thing can also be stated as:	
			currentSubarraySum = Math.max(num, currentSubarraySum + num);
		
		
========
TODO:
quick sort and related probs	

Java useful calls
====================
map: putIfAbsent instead of getOrDefault


New Done probs:
https://leetcode.com/problems/search-insert-position/
https://leetcode.com/problems/palindrome-linked-list/
	-way1
		-put all elems in arr/arrList and check if palindrome 
	-way2 -O(1) space, asked by FB
		-find mid of list (slow and fast ptr technique - run loop till both slow and fast != null)
		-reverse 2nd half in place (-begin with prev = null, and restick links while curr != null)
		-compare 1st half and 2nd half, one by one 
	-way3
		-find mid 
		-use stack to store 1st half 
		-compare one by one with other half 
	-way4
		-recursive and its O(n) space in call stack though 
		
https://leetcode.com/problems/longest-consecutive-sequence/solution/	
	graph and BFS way - 2O(n)
	-One way of looking at this is as a graph traversal problem in which there are multiple disconnected subgraphs and we need identify the largest sub-graph.
    -A node 'num' is directly connected to its neighbours 'num-1' and 'num+1' if present in the array.
    -So basically we first prepare an adjacency list 'map' while iterating through all the array elements.
        //partial adj list, one node can help u get +-1 , and that node will lead u to its +-1
    -Now we do a BFS for each sub-graph and find out its size. If it's greater than 'max', we update max.
    -While doing BFS, we keep track of global visited node to avoid running into cycles.
    -Finally we return 'max'

	TODO - O(n) hashmap way 
		-Map(num, seqLen)
		for each n, check map for n-1 and n+1 -> then update those entries as well with len 
		len = 1 + leftLen + rightLen 
		
		-update farthest entries
			map.put(n - leftLen, sum);        
			map.put(n + rightLen, sum);//update farthest entries
                
                //following does not work!
                //map.put(n - 1, sum);
                //map.put(n + 1, sum);

https://leetcode.com/problems/palindrome-partitioning/submissions/
	-normal way is recursion+backtracking 
	-recursion helper method with begin/start ptr , maintain list of curr_palindrome_substrings 
	-loop from "start" till str.len to try all subtrings for palindrome 
	-if palindrome, then only make recursive call 
	-backtrack by removing last added palindrome from curr_palindrome_substrings
	
	-DP way TODO 

https://leetcode.com/problems/sort-list/solution/
	TODO
	-understand getMid method
	-understand merge method - simple - Qn - merge 2 sorted LL


FB:
https://leetcode.com/problems/valid-word-abbreviation/submissions/
	-lesson - 
	-using for(char: abbr.chars) type loop, instead of maintaining index of abbr. that will add complexity 
	-after pattern/abbr loop finishes, we may or my not have reached solution still.
	-to pass, wordPtr MUST reach word.length (more than that or less both are invalid)
https://leetcode.com/problems/valid-palindrome-ii/
	-use 2 ptr when want to remove char to skip char.
	-try simple iteration. use helper method for ispalindrome with 2 ptrs, l and r
	-recursive solution is possible
		-dont mix iteration and recursion. make it pure recursion, for every char, u call recursion.
	OR:
	I think a good way for the (generic) followup may be using Longest Palindromic Subsequence.
	If the LPS has length >= n-k, then return true. O(n^2) algorithm.	

https://leetcode.com/problems/range-sum-of-bst
	-simple yet easy to get lost
	-recursive is easy. maintain external sum var 
	-Easiest is:
		-just traverse like binary tree and if val is in range, add to sum.
		But to leverage BST prop 
	-see which side we need to go.
	-IMP to note that - sometimes we have to go both sides, sometimes only one side 
	so use if + if and NOT if,else 
	this: range 5,15 and 
		tree: 5 ->10 <-15
		tree: 5->10->15 (only left edge, 5 is at bottom)
		tree: 5<-10<-15 (only right edge, 5 is at top)
		
https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/
	-dont think recursively here (brute force recursion gives TLE anyways)
	-We can use stack to eliminate duplicates, just like recursion.
	for each c, if(c==s.peek())
			remove from stack (s.pop())
		else
			s.push(c)
	
	-actually we dont even need stack 
		-we can do same thing with maintaining stringBuilder as res and iterating over string char by char 
		
https://leetcode.com/problems/simplify-path/
	-dont overcomplicate it by going char by char 
	-specially because there can be lot of combinations of paths. eg: /a/b/c/.././././//d
	
	-Just split string/path with '/'
		-and process each section 
	Following rules:
		-we need to skip .
		-by splitting with / we will have "" for // or more slashes, so ignore any "" section.
		-for .. , if we have prev dir on stack , remove it, otherwise ignore ..
		Thats it ! :)
		
https://leetcode.com/problems/binary-tree-vertical-order-traversal
	-we need to group elems by columns
	-ALSO, each column should be sorted top to bottom order 
	
	-columns wise grouping can be achieved by DFS (BFS as well) by keep tab of +-1 at each left/right move
	-vertical top-bottom order in each column - CAN be naturally achieved in BFS (without maintaining height param)- think level order traversal.
	So go by BFS (queue) rather than DFS (recursion)
	
	-with BFS, use Java's Pair class Pair<TreeNode, Integer> -int is column 
	make Queue of Pair<TreeNode, col>
	
	-TreeMap<col, ArrayList<int>>

https://leetcode.com/problems/nested-list-weight-sum
	-very good recursion exercise
	-pass depth param to recursive function 
	
https://leetcode.com/problems/diagonal-traverse/
	todo 
	-realize that even after switching direction/diagonal, we can run out of boundary on each 4 walls. also flipping is not always same, diff in top half and bottom half of rectangle 
	
