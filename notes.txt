2021_lc_coding
===================
1st round progress:
Every topic sorted by difficulty: easy to hard

Topics to cover:
-------------------
1. Binary Tree 
2. Binary Search
3. Array
4. bfs and queue
5. dfs and stack
6. Graph, topological sort 
7. HashMap
8. Strings
9. LinkedList
10. Dynamic Programming (many arrays and string problems here)
11. backtracking, recursion
12. Priority Queue
13. Greedy - nice to have

Practice by technique
-----------------------
-Sliding window
-2 pointers
-fast and slow pointers 
-DP
-interval type problems 
-cyclic sort?
-modified binary search 
-top-k elements

===================
===================
===================

1. Binary tree : 
---------------------
To remember-redo-practice:
	lesson_binary-tree-postorder-traversal.java	-> there are mutiple ways to iterate using stack. see which one suites me.
	
Continue from:
	102 Binary Tree Level Order Traversal



2. Binary search : 
---------------------
To remember-redo-practice:

Continue from:
	1099	Two Sum Less Than K

3. Array:
----------------------
github

Continue from:m_set-matrix-zeroes.java
	[hard remaining]

to remember:
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_daily-temperatures.java	-> stack the indices rather than temp vals, because we need index diff. -> start from end -> monotonic stack.
	4 sum
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_3sum-closest.java
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_3sum-smaller.java
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_find-all-duplicates-in-an-array.java
	
	cherry pick algo:
	https://leetcode.com/problems/remove-duplicates-from-sorted-array/ - remember the basic trick, write ptr, read ptr. no need to run fast pointer all at once
		-write/good ptr. ptr to track index to unique elems. (slow, write location) => this of this ptr as if we had new empty array where we store desired elems for return. ptr in that array where we can write new elem.
		-iterator ptr (fast, read ptr)
		=>similar qns: (in place array operations - single iteration solutions)
			https://leetcode.com/problems/remove-element/
			https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
			
		-write ptr and iterator will diverge as we start seeing duplicates to be removed.
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sliding-window_grumpy-bookstore-owner.java
	
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sort-colors.java
		-ptr to color 0, at 0
		-ptr to color 2, at len-1
		-iterate over array using i => while(i<=p2)
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_subarray-sum-equals-k.java
		-Sliding window cannot be used, because array contains negative number
		-Its "prefix sum" problem.
		-Solution 1. Brute force. We just need two loops (i, j) and test if SUM[i, j] = k. Time complexity O(n^2), Space complexity O(1). 
		-Solution 2. From solution 1, we know the key to solve this problem is SUM[i, j]. 
			-we need faster way to find SUM[i, j]
			-So if we know SUM[0, i] and SUM[0, j], then we can easily get SUM[i, j]
				SUM[i, j] = SUM[0, i] - SUM[0, j]
			
		-since we are asked to count HOW many times we see the sum, we need to store the Map<sumseen_sofar, count>
		-keep recording sum so far in map.
			-if we have seen  ( SUM[0, i] - target ) -> add this to answer.
			
	m_set-matrix-zeroes 
		-A straight forward solution using O(mn) space is probably a bad idea. track 0 converted elems/visited elems. so that we dont consider them original 0s.
		-improvement: only track col and row nums which needs to be zeroed. PAss1: record these rows and cols. PAss2: zero down those rows and cols. 2*O(mn)
		- work on memory efficient soln
			-> use this soln: https://leetcode.com/problems/set-matrix-zeroes/discuss/26008/My-AC-java-O(1)-solution-(easy-to-read)
			-They are using the first row and column as a memory to keep track of all the 0's in the entire matrix.
			-only problem with that is : if 0th row or col is 0.
	product-of-array-except-self -> need to do without division. -> realize that product except self = product(on left) + product (right)
		-> that can be achieved without creating extra arrays for left and right.
		->iterate left to right skiping sefl
		->iterate right to left skipping self. both times record res in same array. that will be ans
	
4. 	BFS and queue:

There are 2 aspects to BFS.
-some problems, first figure out which all nodes need bfs and add them in queue.
-some problems, just start with one node in queue as starting point.

-level order traversal.
-iterate thru all neighbors?

Continue from: https://leetcode.com/problems/perfect-squares/

to remember:
	https://leetcode.com/problems/evaluate-division/solution/
	https://leetcode.com/problems/the-maze/solution/
	https://leetcode.com/problems/rotting-oranges/


5. HashMaps
Continue from: github
	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_insert-delete-getrandom-o1.java
to remember:
	-log rate limiter - study various approaches IMP
	https://leetcode.com/problems/next-greater-element-i/
	https://leetcode.com/problems/isomorphic-strings/
	https://leetcode.com/problems/find-duplicate-subtrees/
			https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_group-shifted-strings.java --> key forming math
	https://leetcode.com/problems/time-based-key-value-store/		

6. Binary Search 
continue from:
	h_median-of-two-sorted-arrays.java
	
to remember:
	m_Search_for_a_Range.java 
		-> use template-1 (l<=r) and record target index each time. Sicne we are looking for exact match - template1 is suitable.
		- template 2 (l<r) has issues - might get into endless loop.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/e_valid-perfect-square.java - use long instead of division technique. because division will lead to false true. (2 = 5/2 - but its not perfect square)
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-first-and-last-position-of-element-in-sorted-array.java
		-dont use while(l<r) template - problem narrow downing the end
		-use while(l<=r) template 
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-k-closest-elements.java - template III mid+k widnow
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_search-a-2d-matrix-ii.java - TODO binary search way. currently doing narrowing down method, beginning bottom left corner.
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-minimum-in-rotated-sorted-array.java
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_search-in-rotated-sorted-array.java
	
todo:
h_median-of-two-sorted-arrays.java	
https://leetcode.com/problems/time-based-key-value-store/

7. DFS
continue from:
	TODO: hards
	
to remember:
	m_basic-calculator-ii.java -> little not intuitive. keep putting + and - operands in stack. * and / calculate in run time.
	m_copy-list-with-random-pointer.java -> need to use HashMap<origNode,newNode> as visited record, instead of set, because we need to retrieve new node to reuse (from given visited node)
	m_decode-string.java -> when encounter [, we need to push stringSoFar on stack -> because there can be multiple/nested layers (just like num/count nesting), we we wont be able to store it directly in final result
		->k[string k[string k[string]
	
	m_exclusive-time-of-functions.java -> see as time intervals. Since its logs, its already in chronological order/sorted, so no need to sort by start time. -> now imp to realize use of stack. We dont use PQ here like interval problems (because already sorted by start time). push started tasks in stack (like actual call stack !) -> stack<taskId> only. calculate exclusive time during iteration itself.
		-> when see end log, pop.
		->result can be array and taskId serves as index. so no hashmap required
		->when end log comes, taskid will alway match to top of stack. ()
	m_flatten-nested-list-iterator.java -> imp to realize the recursive nature. since its rec, we can use stack.
		-> during constructore, flatten there itself.
		-> then only provide iteration.
		-> needs practice.
		-> imp: next will not be called without calling hsNext
	m_lesson_all-paths-from-source-to-target.java -> realize that we need to backtrack (remove curr neighbor from path) before next iteration to other neighbor. (after recursive dfs call)
Note: dfs helper function normally will not return anything, its just dfs sweeper. result will be recorded in some class var.

	m_lesson_path-sum-iii.java -> see each root to leaf path as array, and we are looking for subarray that sums to target. for that we use "prefix-sum" technique. so thats what we will do.
		-> imp : consider two nodes having same num (also -ve nums are allowed), so our prefix sum map will need <sumSoFar, frequency>
	
	
	m_word-search.java -> dfs+backtracking -> again exhaustive dfs. whenever there is exhaustive dfs, dont forget to clear/backtrack visited node if word not found here. if the path does not lead to a solution, we then revert the change (i.e. backtracking) and try another path.
		-> also this dfs helper needs to return boolena for whether word found or not. -> so need to OR all dfs directions.
		-> time complexity: Time Complexity: O(N. 3^L) where N is the number of cells in the board and L is the length of the word to be matched.
	
	
8. Strings 
continue from:
	m_trick_multiply-strings
	
to remember:
	e_lesson_most-common-word.java -> good practice of string iteration by chars, and corner cases. -> character.isLetter and stringbuilder are enough to make word. we dont need start and end pointer to make word.
		how do we iterate char by char and derive each word?
		a. use two ptrs -> start and end
		b. use stringbuilder, build it up to one word, usinng just one ptr.
		
	longest-common-prefix - > there are many ways to solve. ->pick 1st string, and compare char by char in rest of strings. stop when dont match and return prefix.
		-> divide and conquer, binary search are possible.
		-> find min and max strings, then compare..
	reorder-data-in-log-files.java -> use String x = a.substring(a.indexOf(' ')+1,a.length());		
		-> also note: comparator for pq -> strA.compareTo(strB)
	reverse-words-in-a-string-iii -> how do we iterate char by char and derive each word?
		a. use two ptrs -> start and end -> in place operations. no extra space needed.
		b. use stringbuilder, build it up to one word, usinng just one ptr.
	e_strstr.java -> brute force match at every char position in bigger string.
	e_trick-greatest-common-divisor-of-strings.java -> GCD for string is the biggest common substring. so we need to keep cutting substrings from begin point until we cant.
		-> if one string is empty, other is the answer to return.
	e_unique-email-addresse -> to replace occurences of . in string:  id = id.replaceAll("\\.","");   //remember this utility and \\ for before .
	m_atoi.java -> there are corner cases to be covered:
		0. remove spaces from front and back - trim
		1. sign in front - may or may not be present
		2. Integer overflow min and max. Store temp result on "long"
		3. look for non digit chars. once encounter, break/stop
		-> use long to store intermediate result to check int overflow. converting string to int, char/digit by digit. 
	m_group-shifted-strings ->
		 key += String.format("%2d", (s.charAt(i) - s.charAt(i-1) + 26) % 26);//Difference from the previous char.
		 ->circular shifted strs in same group
	m_lesson_compare-version-numbers.java -> 
		-need to consider various corner cases: Following are equal:
			1.0 and 1.000
			1.0 and 1.0.0
			1.01 and 1.001
		->split string by dots
		->create utility to convert string to int.
		-key to make soln easy-for diff length, we can use 0 for whichever finished.
	m_lesson_longest-substring-with-at-most-two-distinct-characters.java -> need to store HashMap<char, latestIndex> -> we store latest/last index because, if we were to remove that char, we need to remove till right most occurence of that char.
		-> only use of left ptr is to cal len of substring. not for remove char from left side.
		-> but leftmost cant be tracked with ptr, each time need to go over map and find leftMost char to remove from sliding window
		-> note: it is possible to solve with lft and right ptrs and slide from left one by one and map<char,freq>, but as straight as above.
	m_lesson_partition-labels.java ->
		it sounds complicated, recursive and dp problem, but its not !
		->2 pass solution:
        -Record the last occurence of each letter in map
        -Second pass can be done in way that we will get max partitions.
			-Keep current interval window marked by begin and end pointers
            -keeptrack of furthest most index of occurence for any letter in current interval.
            -if that is = i, we dont have anymore repeating in future, so partition window ends here. add it to result.
                Note: We END it here rather than including more unique chars because we want as many unique intervals as we can.
	m_longest-substring-without-repeating-characters.java -> set is enough with sliding window. map not required here.
		-> when we slide from left, we dont increment the right ptr. because duplicate might just be right -1 ! eg: abcdee -> when we sit at right = 2nd e.
	m_palindromic-substrings.java -> 
		-count palindrom from odd center. (i)
		-count palindrom from even center. (i,i+1)
			-to cehck palindrome, run loop to expand from center.
		-do this for every i from 0 to len 
	m_reverseWords.java
		->trim both ends first 
		->now rever the string then reverse each word. -> wo do this to avoid extra space. if we dont reverse, we will store each word in array/stack. ->then build string with words in reverse order.
	m_trick_fraction-to-recurring-decimal.java
		-explained well by diagram in leetcode.
		-> main trick : if remainder starts repeating, we know its repeating and finish
		-> we need to know where the repeating part starts. index of each digit in fraction -> do it by hashMap<Long, index>
		-> we use Long for all calculations to cover int overflows 
		-> how do we keep reducing remainder? -> this is just plain division operation.
			long remainder = dividend % divisor;
			-> while(ramainder ! = 0){
				ramainder *= 10; --> whi mult by 10? that is how we proceed manunal division
				remainder %= divisor;
			}

9. Priority Queue - Interval types
Note:
if we need top -k elem 
	-we can do it with PQ size of k+1
	-for max, make min heap. add k+1 elems. if (pq size >k)->poll top elem.
		-this will end up in top k elems in pq.
		
todo:
	lesson_car-pooling.java
	task-scheduler.java
	
to remember:
	m_exclusive-time-of-functions.java -> see as time intervals. Since its logs, its already in chronological order/sorted, so no need to sort by start time using PQ. 
		-> now imp to realize use of stack. We dont use PQ here like interval problems (because already sorted by start time). 
		->push started tasks in stack (like actual call stack !) -> stack<taskId> only. calculate exclusive time during iteration itself.
			-> when see end log, pop.
			->result can be array and taskId serves as index. so no hashmap required
			->when end log comes, taskid will alway match to top of stack. (first to end will be last to start - because its single threaded - V Imp - this is why we are able to use stack only)
	
	m_interval-list-intersections.java 
		->iterate with ptrs over both arrays together
		->overlap interval = [biggerStart,smallerEnd]
			->then which ptr to move ?
			move minEnd
		->since we are looking for overlap - nothing to do after loop exits
	
	m_meeting-rooms-ii.java
		->first sort intervals by start time.
		->use pq to store intervals - sort by end time - min heap - so we get roo first to finish.
			-actually we are only using end time from intervals in pq. so we only need pq<Integer>
		->if new start-time >= end-time from pq, re-use room
			->remove this pq top interval - room can be reused.
		->add new interval to pq.

	merge-intervals.java
		->sort them by start time 
		->iterate and merge
			->while its possible to add loop inside to merge till we can with curr elem. since we are not doing it in place - not modifying given array, returning new arr, we wont do it. 
			->thats not good idea, complicates loop
			->just merge one at a time. while keeping track of prev interval.
	
	reorganize-string.java
		->map chars by count.
		->store int[charASCII, count] in pq -> max heap
		->now keep polling pq and interleave.
			->poll one, append in stringBuilder, reduce its count 
			->that is now prev
			-> use prev to keep track of char we just used in result in last iteration. -> because we need to add it back to pq if count >0
			aab 
				1->remove a from pq 
				2->next time remove b, 
				-> prev is a. put back in pq.
				->add b in result -> ab -> then prev becomes b 
				3->prev = b but count == 0, so dont add in pq.
					->add a to result -> aba 
			->so, if (pq is empty && prev count > 0	) -> eg: aaab
				->then we can find elems/char to separate all "a". so return false 
				
	merge-k-sorted-lists.java
		->add 1st elem of all lists to pq (min sorted)
		->now link nodes to create new ordered/merged list
		->now till pq is empty
			->poll, 
			->make linkage -> curr.next = polled -> curr = curr.next 
			->add curr's/polled's list's next elem to pq (if non null ie, list has not ended)

10. Graph 
notes under graph directory.

continue from:
todo:
	-All Paths from Source Lead to Destination
	-remaining from done probs on LC
	
11. Sliding window:

to remember:
	->https://designgurus.org/path-player?courseid=grokking-the-coding-interview&unit=grokking-the-coding-interview_1628541055153_6Unit	
		-we dont have to worry about consecutiveness of window for pattern anagram/permutation
		-the matchCharCount combined with checking at each char, will take care of it.
		-so, just store <char,count> map for pattern, and decrement,increment it as we slide char by char.
		

12. Backtracking/recursion
-starting from leetcode 

todo:
	https://leetcode.com/problems/restore-ip-addresses/
	n-queens
	https://leetcode.com/problems/remove-invalid-parentheses/
		-doable both DFS and BFS.
		-trick for validity : 
			if ( count++
			if ) count--
			if(count <0) -> invalid/false
		-no need to worry about char inbetween. parantheses validity will be same regardless of chars between them.
	
	https://leetcode.com/problems/remove-invalid-parentheses/
		-DFS+trie
		-need of trie comes from the fact that we need to know that we have a prefix match so that we can keep continue down this route. otherwise waste of runtime.
		
		
continue from:
	-sudoku solver
	
Note:
-think recursive prob as solving subproblem. eg: 
	-Permutation: abc -> a + permutations of (bc)
	-subset: abc -> a + subsets of (bc)
	-so we solve subproblem first, as a result output will be in that order.

-permutations output order for swap based recursive algo
	Input: nums = [1,2,3]
	Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
	
-duplicates: 
	-the first call at any level is i=beginIndex: so we need to allow i=beginIndex but avoid duplicates.
		so: if(i!=beginIndex && twoNumsAreStillsame)
	-we normally sort entries so that duplicates are together. we might get away without sorting for permutation because of swap, but for subsets we need to.

-subsets output order will be:
	Input: nums = [1,2,2]
	Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
	if(soFar.size() > 0){
		ret.add(new ArrayList(soFar));//we make new cipy of list to add in result because this copy will keep modifying.
	}

-https://leetcode.com/problems/word-search/solution/
	-combintion of DFS and backtracking - super problem.
	-backtracking is during each DFS for visited nodes.
	-NOTE: visited boolean[][] does not have to be created fresh for every DFS starting point x,y. since we are backtracking and clearing flags, same map can be reused as is dugin next x,y DFS check.
	
