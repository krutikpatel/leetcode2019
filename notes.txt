2021_lc_coding
===================
1st round progress:
Every topic sorted by difficulty: easy to hard

Topics to cover:
-------------------
1. Binary Tree 
2. Binary Search
3. Array
4. bfs and queue
5. dfs and stack
6. Graph, topological sort 
7. HashMap
8. Strings
9. LinkedList
10. Dynamic Programming (many arrays and string problems here)
11. backtracking, recursion
12. Priority Queue
13. Greedy - nice to have

Practice by technique
-----------------------
-Sliding window
-2 pointers
-fast and slow pointers 
-DP
-interval type problems 
-cyclic sort?
-modified binary search 
-top-k elements

===================
===================
===================

1. Binary tree : 
---------------------
Tree:
			1
		2		3
	4		5
Depth First Traversals: 
(a) Inorder (Left, Root, Right) : 4 2 5 1 3 
(b) Preorder (Root, Left, Right) : 1 2 4 5 3 
(c) Postorder (Left, Right, Root) : 4 5 2 3 1
	
to remember:
	-https://leetcode.com/problems/closest-binary-search-tree-value/
	
	-lesson_binary-tree-postorder-traversal.java	-> there are mutiple ways to iterate using stack. see which one suites me.
	-balanced binary tree - 
		-top-down -check each node is balanced with helper method of height. O(n^2)
		-botttom up O(N) - needs node to store info - whether its balanced or not. build up on that.
			-even without storing info - bottom up is O(n)
			-visit eaach node once - Post order - call both children first.
			-this O(n) method to look for heigh difference called once only. store result in class var OR propagate in ret val.
		-THERE IS SUBTLE DIFFERENE BETWEEN THESE TWO IMPLEMENTATIONS THAT I DID NOT UNDERSTAND YET
		-same technique is used here for O(n):
			https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/e_diameter-of-binary-tree.java
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/e_lesson_subtree-of-another-tree.java
		-checking at each node is O(n^2)
		-converting tree to string - but order matters
		IMP - order matters. inorder will not work.
		ONLY preorder will work. its node by node comarision from top.
		ALSO: we need to count null leafs in string too, to avoid wrong comparisions, which gives false true.
        -to avoid returning true for example 2 above
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_binary-search-tree-iterator.java
		-next returns min elem - thus its in order retrival
		-we can use stack to store in-order sequence
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_count-univalue-subtrees.java
		-check for curr node as univalue 
			if(n.right !=null && n.right.val != n.val)
                return false;
            if(n.left !=null && n.left.val != n.val)
                return false;
		-no need to overcomlicate - one helper method traversal over whole tree is enough. no need to pass down n.val
 		-post order traversal/DFS - call l & r, then decide if parent is univalue.
		
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_find-duplicate-subtrees.java
		-convert tree in string (INCLUDING NULL NODES) 
		-only certain order will work - POST order 
		-ONLY add dplicate trees to result once
			-For people who are curious about why in-order doesn't work, here's a simple example:
			TreeA:
			0
			/
			0

			TreeB:
			0
			\
			0

			They both have same in-order serialization "#0#0#" if we just use "#" to represent null.

	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_flatten-binary-tree-to-linked-list.java
		TODO 
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_boundary-of-binary-tree.java
		-i think can be done with level order traversal.
		-store 1st in left and last in right lists.
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_inorder-successor-in-bst.java
		-successor will be right of x -> once u go right it can be n or n.left
		-keep going left and right as per BST, whenever go left (record n as return value first)
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_insufficient-nodes-in-root-to-leaf-paths.java
		-good one with regards to passing vals and returning node and making links
		Also, IMP to note that we do : DFS in POST order traversal way. ie, we go to leaf first, we call left and right first,
		then we can decide whether a parent is sufficient or not
		IMP:
		1.although its like postorder, we process sum before calling children, because sum has to be passed down.
		2.we check if its leaf node, and check sum condition here. BEcause we need to return from here.
			-if we go to null node, it will always return null, and upper level will think that its insufficient.
			
		-pass down sum sofar
		-if sum < target at leaf, return null 
		-if n.l and n.r both becomes null, return null. -delete this node.
		
		=>There are two codnitions when we return null, or remove nodes:
			1. if sum < target at leaf, return null 
			2. both left and right are null, so they point to no good path.
			
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_kth-smallest-element-in-a-bst.java
		-in-order tarversal and counter k (incement/decrement happens in-order, on current node. so counting does not start til lwe reach left most) - we dont have to worry about reaching left most elem and then start counting exclusively. that is part of "in order" processing.
		-that needs helper method (and class var for result ). cant be done in-place otherwise.
		-recursive - if we dont want class var - pass arr [counter,retVal]
		-iterative using stack, recursive usual. 
		
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_lowest-common-ancestor-of-a-binary-tree.java
		-first thought comes is helper method to find 2 elems under given node 
		-BUT we dodnt need that extra FIND method O(n^2)
		-//if root is p or q, that is LCA
        if( root == p || root == q || root == null)
            return root;
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_most-frequent-subtree-sum.java
		-dont need to calculate sum at each node separately
		-traverse tree once and record sums in map. map<sum,count>
		-sum = left+right+curr
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_serialize-and-deserialize-binary-tree.java
		Ser:
		pre-roder, # for null and ',' as delimiter
		Logic Note:
			-Serialization: we used recursion in pre-order manner
			-Deserialization:
				-we have data in certain order. to reuild tree out of it, follow same order 
				a-data was built with recursion, so use recusrion
				b-order was pre-order - so use pre-order
				c-how to fetch elems in deserRecFunction that order?
					-use Q to fetch elems in that order. (can be done using array and index, but prone to error)
					
		Deser:
		Queue + preorder resursion
		Use Queue<> for deser, put all nodes in Q and just recreate tree in Pre-order fashion
		-Use Queue as FIFO, because thats the order in which we want to remove elems from list
		-IMP thing is deser is done in recursive fashion, just like pre-order, and elem taken from Queue every time in FIFO order

		-serialie - tree to array/string 
			-DFS pre-order traversal suits prob - bcoz that will make deser job easy. need to put null indicator in string 
		-desrialize - split string with delimiter ',' to get array 
			-use Queue , insert array in Queue - to get FIFO order
			-remove them one by one and just link them recursively (pre-order recursion)
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/h_binary-tree-maximum-path-sum.java
		-DFS/Post order traversal helps with O(n) path sum cal
		-imp to think which all paths are valid, and can possibly max . nodes can have -ve values 
		-maintain class level max 
		-helper: return currPathMaxSum - so that upper level can be max 
						-that is currPathMaxSum = n.val + Math.max(l,r);
				-for l and r, important to take 0 if return val is negative, so that currPath does not become less due to -ve children.
		
Continue from:
	102 Binary Tree Level Order Traversal
	and githun from:
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_trim-a-binary-search-tree.java


2. Binary search : 
---------------------
To remember-redo-practice:

Continue from:
	1099	Two Sum Less Than K

3. Array:
----------------------
github

Continue from:m_set-matrix-zeroes.java
	[hard remaining]
TODO:
https://leetcode.com/problems/top-k-frequent-elements/ - add this to github
	-we maintain min PQ, and keep adding. when size > k , we remove. so top gets removed, which is min. so in the end, we have top/max k elems in PQ! 
	
to remember:
	https://leetcode.com/problems/squares-of-a-sorted-array/
		-give that array is sorted. AND can contain -ve nums 
		max square of -ve num will be greater at 0 index and decreases
		-create extra ret arr
		-fill from end 
		-only problem is -ve elems 
		-keep 2 ptrs : l and r 
			-regardless of there is -ve or not, 
			ret[i] = max of Sq(l) and Sq(r) 
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_daily-temperatures.java	
		-> stack the indices rather than temp vals, because we need index diff. -> start from end -> monotonic stack.
		-pop first till stack top is less than curr 
		-then push curr anyways 
		imp - we store index in stack
		
	4 sum:
		-For each elem [i], solve k-1 problem recursively, at k=2, solve 2sum problem
			-2sum loop/sweep shud not end as soon as we find pair, because we need to find ALL pairs to continue till (l<r)
		
		-Time complexity is O(N^(K-1)).
		-generalize as :
		private List<List<Integer>> kSum(int[] nums, int target, int k, int leftBegin)
		-run loop till it becomes 2 sum prob OR k=2
			-that k loop looks like :
			for (int i = left; i < len - (k - 1); i++) {
                //use current number to reduce ksum into k-1sum
				//arr[i] will be part of sol list
                List<List<Integer>> curr = kSum(nums, target - nums[i], k-1, i+1);
				=> then add arr[i] to each lists returned
				
		-duplicate check has to be done in 2 sum as well as other loop too 
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_3sum-closest.java
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_3sum-smaller.java
		-tricky - there is more than just counting at each 2 sum sweep.
		-at any given 2sum sweep : if(localsum<target)
			-we need to count all combinations keeping "low or l constant". 
			x,l,r
			x,l,r-1 
			x,l,r-2 etc
		-that will not be covered in next iteration. bcoz if localsum<target, we will move to l++
			
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_find-all-duplicates-in-an-array.java
		-nums are 1 to n -> convert that to index/bucket as arr[i]-1
		-every time we see num, we do x * -1
		-so if num seen only once, it will be -ve 
		-second loop can catch this 
		-use Math.abs while calculting index, because num can be -ve as done by us only 
		
	cherry pick algo:
	https://leetcode.com/problems/remove-duplicates-from-sorted-array/ - remember the basic trick, write ptr, read ptr. no need to run fast pointer all at once
		-write/good ptr. ptr to track index to unique elems. (slow, write location) => this of this ptr as if we had new empty array where we store desired elems for return. ptr in that array where we can write new elem.
		-iterator ptr (fast, read ptr)
		=>similar qns: (in place array operations - single iteration solutions)
			https://leetcode.com/problems/remove-element/
			https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
			
		-write ptr and iterator will diverge as we start seeing duplicates to be removed.
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sliding-window_grumpy-bookstore-owner.java
	
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sort-colors.java
		-ptr to color 0, at 0
		-ptr to color 2, at len-1
		-iterate over array using i => while(i<=p2)
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_subarray-sum-equals-k.java
		-Sliding window cannot be used, because array contains negative number
		-Its "prefix sum" problem.
		-Solution 1. Brute force. We just need two loops (i, j) and test if SUM[i, j] = k. Time complexity O(n^2), Space complexity O(1). 
		-Solution 2. From solution 1, we know the key to solve this problem is SUM[i, j]. 
			-we need faster way to find SUM[i, j]
			-So if we know SUM[0, i] and SUM[0, j], then we can easily get SUM[i, j]
				SUM[i, j] = SUM[0, i] - SUM[0, j]
			
		-since we are asked to count HOW many times we see the sum, we need to store the Map<sumseen_sofar, count>
		-keep recording sum so far in map.
			-if we have seen  ( SUM[0, i] - target ) -> add this to answer.
			
	m_set-matrix-zeroes 
		-A straight forward solution using O(mn) space is probably a bad idea. track 0 converted elems/visited elems. so that we dont consider them original 0s.
		-improvement: only track col and row nums which needs to be zeroed. PAss1: record these rows and cols. PAss2: zero down those rows and cols. 2*O(mn)
		- work on memory efficient soln
			-> use this soln: https://leetcode.com/problems/set-matrix-zeroes/discuss/26008/My-AC-java-O(1)-solution-(easy-to-read)
			-They are using the first row and column as a memory to keep track of all the 0's in the entire matrix.
			-only problem with that is : if 0th row or col is 0. - >becaues if so : if 0throw is 0, we need to make 0th col zero as well. as same for cols 
			-so use 2 more flags to indicate if fr or fc is zero.

	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_product-of-array-except-self.java
		-> need to do without division. -> realize that product except self = product(on left) + product (right)
		-> that can be achieved without creating extra arrays for left and right.
		->use same arr for both loops. and that will be our ans 
		->iterate left to right skiping sefl
		->iterate right to left skipping self. both times record res in same array. that will be ans
	
	m_interval-list-intersections
		-iterate over both together 
		-find out if there is intersection 
		-then decide which arr to proceed 
	
	m_prison-cells-after-n-days
		-in-place modification of arr not possible, coz we need orig values of cell till end.
		-so create new arr to store the result. create hlper method to do this and return new arr 
		Optimization:
		-there is possibility of cycles if we change values N times.
		-in that case we can store result in hashSet and see if we have seen this before. if so, dont continue N days loop. its cyclic 
		-record at which iteration we got cycle 
			if(hasCycle){
				N%=cycle;
				for(int i=0;i<N;i++){
					cells = nextDay(cells);
				}   
			}
	
	https://leetcode.com/problems/rectangle-area/
		-calc both rectangle areas (x2-x1) * (y2-y1)
		-find overlap points
			-find overlap points and apply formula like above 
	
	m_trick_gas_station
		-tricky yet simple algebra
		-we dont have to try each position exclusively, single iteration is enough 
		-gas[] - gas_available
		-cost[] -gas_needed ( cost or dist )
		-track gasAvailable after each node 
		-if gasAvailable  -ve, that node is not answer 
		-at end if gas_needed+gas_available > 0 we are in surplus and can make it.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sliding-window_grumpy-bookstore-owner.java
		-sliding window technique !
		-count normal sum of whole array.
		-now slide window of sixe X (counting/adding 1's to satisfied custs)
		-now keep sliding till end, and recor max every time we slide 
		==> or just dont count sum in advance and do it?
			-count satisfied custs while iterating
			-keep track of max in window and keep sliding 
		
4. 	BFS and queue:

There are 2 aspects to BFS.
-some problems, first figure out which all nodes need bfs and add them in queue.
-some problems, just start with one node in queue as starting point.

-level order traversal.
-iterate thru all neighbors?

Continue from: https://leetcode.com/problems/perfect-squares/

to remember:
	https://leetcode.com/problems/01-matrix
		-natural instinct : start from 1's go find till 0 reached.
			-that BFS is only good if we were to find shortest distance for that 1 cell. To find it for ALL cells, we will need separate BFS from each cell.
		-So, rahter, start from eacch 0 cells as BFS in parallel. 
			-basically statrt from desired destination ("0" cells ) when we need shortest distance (for all ("1")cells ) in matrix.

		1. add all 0 to Q 
		2. we need to take action when se we see 1 (we make them: currCell+1). make all 1's as other constant: MAX (or keep another matrix of unvisited 1's). -we only operate on cell ONCE. so mark them as untouched 
		3. BFS 
			if cell == MAX, convert and MAX to currCell+1, as distance marker for 0 to reach it.
		4.	-Add that neighbor to Q (eg vals: 1,2,3 these are distances)
		5. IMP - in the while(!q.isEmpty()) loop 
				-we just take one cell, and visit all its neighbors. 
				-we dont loop over all q elems in this iteration. actually we never do that ! we always take 1 elem and visit all its neighbors.
				
	https://leetcode.com/problems/evaluate-division/solution/ - DFS 
	https://leetcode.com/problems/the-maze/solution/
		-DFS is more natural here. But BFS has advantage of less heap space.
		-need to keep track of visited nodes 
		-for(4 directions) {
			newpos = roll()
			if(dfs(newPos))
				return true;
		}
		
		BFS
		-add start pt in Q
		-poll Q 
		-add to visited 
		-check if its dest
		for(4 dirs) {
			newpos = roll(dir);
			if(not visited newPos)
				Q.add(newpos)
				
		}
		
	https://leetcode.com/problems/rotting-oranges/
	-first need to cound good oranges, because its possible that whole sweep cannot reach all good oranges, so we need to return -1 in that case.
	-we dont need to store visited nodes.
	-i think because we already recorded all rotten oranges first.
		-we only add nodes to Q once, 
		1. initially
		2. when we convert them to rotten in loop 
	
	maze-ii 
		-how do we keep track of distance travelled for each direction while doing BFS 
			-create a new matrix for that. dist[i][j] = i,j distance from start point.
		-when we roll, we need to return final point where roll stops
			-we also need to return dist travelled. use int[3]
		-create move/roll method, and also create isValid method.
		
	
5. HashMaps
Continue from: github
	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_insert-delete-getrandom-o1.java
to remember:
	-log rate limiter - study various approaches IMP
		-we need LAST 10 sec window, 10 slots. queue, array, circular buffer whatever u think of.
		-Also, we need Set for each slot, so that we know whether incoming log was printed in any of last 10 secs
		a. figure out slot - based on given timestamp. clear old slot if not same. clear old set as well in that case
		b. check if msg was printed in last 10 secs. go thru each slot (see if slot time < 10 secs) and see if present in any of the sets.
		
	https://leetcode.com/problems/next-greater-element-i/
	https://leetcode.com/problems/isomorphic-strings/
		-go char by char 
		-need 2 maps. a to b char mapping and b to a chars mapping. because both sides can break the mapping done earlier.
		-if entry does not exist add (a to b) and (b to a)
		-if either side map entries dont match - false.
		todo: 2 arr technique. same as hashmap, we just use arr as map.
		
	https://leetcode.com/problems/find-duplicate-subtrees/
		representation of tree(segment) can be in terms os String with all nodes in some order (post order here is must)
		-also include null nodes
		-ONLY add dplicate trees to result once
		-we use HashMap<String,Integer> , because we want to know how many times we have seen current path, so that we dont add it to result more than once
		-For people who are curious about why in-order doesn't work, here's a simple example:
			TreeA:
			0
			/
			0

			TreeB:
			0
			\
			0
			They both have same in-order serialization "#0#0#" if we just use "#" to represent null.

	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_group-shifted-strings.java --> key forming math
		-use ascii diff between 2 chars: for 1st char, val = 0
			acf = 0->2->3, and pru = 0->2->3.
			
		-az, ba
			-where az = 0->25 and ba = 0->-1. When it goes negative, 
			-just make it positive(rotate or mod equivalent) by adding 26. So it becomes, ba = 0->25, which forms same group
		[(charA-charB) + 26] % 26 
			-we do +26 beause we need circular progressing index. az if we rotate this, it becomes za, so our key should do that.
			
	https://leetcode.com/problems/time-based-key-value-store/
		-all we need is :
		HashMap<String,TreeMap<Integer,String>> map;
			-for each keyString - we need to store : at what timestmap, what string val we have.
				-if we dont have any at give timestamp, we look for smaller timestamp valString.
			-we need treeMap, reverse sorted by time. latest time first.
			
	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_insert-delete-getrandom-o1.java
		-need ArrayList as main data store. easier for getRandom, as random is based on index.
		-Map<int, itsIndexInList>
			-how to avoid shifting the whole arraylist while remove in middle of list? there is another problem in shiftin, its we stored indices of nums in map, that will change as well!
			-swap elem-x with last elem. and remove last elem. map has to be updated accordigly.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_lesson_find-and-replace-pattern.java
		-same logic as isomorphic strings.
		
6. Binary Search 
continue from:
	h_median-of-two-sorted-arrays.java
	-from : m_lesson_search-a-2d-matrix-ii.java
	
to remember:
	-Note: search in binary tree can be done iteratively. go left or right till reach null leaf 
	m_Search_for_a_Range.java 
		-> use template-1 (l<=r) and record target index each time. Sicne we are looking for exact match - template1 is suitable.
		- template 2 (l<r) has issues - might get into endless loop.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/e_sqrtx.java
		-return closest decimal is perfect square is not available
		-use division to overcome overflow, instead of long. -> because truncation is allowed as per question.
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/e_valid-perfect-square.java - use long instead of division technique. because division will lead to false true. (2 = 5/2 - but its not perfect square)
		-imp to check if its perfect square at end of loop too.
		
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-first-and-last-position-of-element-in-sorted-array.java
		-dont use while(l<r) template - problem narrow downing the end
		-use while(l<=r) template 
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-k-closest-elements.java - template III mid+k widnow
		if(Math.abs(arr[mid]-x) > Math.abs(arr[mid+k]-x)){
		-we are comparing mid and mid+k to decide which side to go.
			
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_search-a-2d-matrix.java
		-imp: see whole matrix as one single sorted array!
		for arr elem i, row = i/n, and col = i%n 
		-do normal binary search over that array.
		
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_search-a-2d-matrix-ii.java - TODO binary search way. currently doing narrowing down method, beginning bottom left corner.
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-minimum-in-rotated-sorted-array.java
		-what to do if there are duplicates?
		-if(nums[mid]==nums[right])
			reight--;//to skip dups
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_search-in-rotated-sorted-array.java
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_kth-largest-element-in-an-array.java
		-use quick sorting. quick sort partition step gives small nums on left of pivot selected.
		-so turn kth largest prob into len-kth smallest elem. k2 = len-k
		-partition method is recursive till we find k2 elems in left partition
			-if l> r return IntMAX
			-for partition, maintain writePtr = l, 
			-after loop, swap one more time 
			-if nums left of pivot == k2 return that index. 
			-if nums left of pivot > k2 -> go left
			else go right 
	
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_floor-function-sorted-array.java
		--normal bianry search function : if val not found, it ends up at smaller closest !
		-so use template 1, and keep recording val if its <x, at end of loop that will be our answer.
		-template 2 also popssible

	https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size/
		-find lower bound and upper bound to perform binary search.
		start with l,r = 1;
		while(arr.get(r) < target)
			r = r*2;
		//at this point arr(r) > target. so upperbound = r.
		l = r/2	;//that must be lower bound, because we only broke condition in last iteration.
		l...target ....r 
		
todo:
	h_median-of-two-sorted-arrays.java	
	https://leetcode.com/problems/time-based-key-value-store/
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_floor-function-sorted-array.java
		--normal bianry search function : if val not found, it ends up at smaller closest !
		-so use template 1, and return nums[start] after loop.
		-template 2 also popssible
	m_lesson_online-election.java
	
todo:
Some of the Binary Search based Interval Problems :)
57. Insert Interval - https://leetcode.com/problems/insert-interval/
436. Find Right Interval - https://leetcode.com/problems/find-right-interval/
729. My Calendar I - https://leetcode.com/problems/my-calendar-i/
1235. Maximum Profit in Job Scheduling - https://leetcode.com/problems/maximum-profit-in-job-scheduling/
2054. Two Best Non-Overlapping Events - https://leetcode.com/problems/two-best-non-overlapping-events/

IMP note:
===================
-template2 - given that arr is ascendin sorted, and we do l = m+1 when x<target
IMP - below obs are in terms of "index", l is index. Not the elem at index.

	Obs1 . what index does template-2 settle at? what is end val of l - when elem not found?
		->it settles on left/smaller (closest) side of target!
			-so if target was greater than the max num of arr, it WILL settle on last index of arr. !
		->that means normal template 2 serves as "CEILING" function. 
	
	Obs2
		-template2 will always return a "VALID" index. (0 to len-1)
	
	Obs3
		-template1 may return a "INVALID" index. (0 to "len") - when num is bigger than upper bound
	
	Obs4
		-template 1 also settles on the num (closest Bigger) than target, if target not in arr.
		-so it serves as "CEILING" function (except last elem, for which check is needed)
--------	
IMP:
	-we dont have to memorize limits. 
	-limit/bounds are defined by us/algo itself.
	l=0,r=len-1 
	while(l<r)
		-->here l cannot go below 0
		-->l cannot go above r, it can be r when loop exits . r = len-1, thus valid index 
--------	
		
	-sometimes, when we want to derive a fitting index (may be elem?), we need to be careful of 'r'
	-normally r = arr.len-1 
	but if we want to settle to correct index - we may want to set r = arr.len
		Example:
		https://leetcode.com/problems/search-insert-position/
			-if target is out of array 
			-we have to imagine array is len+1. and return index accordingly
			-template1 works very good here. BUT if we want to use template2, we need to set r = arr.len
			
	-Think another problem: 
		1. return index of elem smaller than target 
		2. return index of elem bigger than target 
		3. floor function 
	
	-Trick on template2 
		-to get floor functionality out of template 2:
			set l = 1 and r = len
			-because we know it will settle down on celingin elem 

Floor-function: TODO - I think it is same as search insert position problem! but here, if elem = target, we cant return that, we want floor of the target.
	-there are only 3 possibilities
		-target below 0	-> ret: -1
		-target above arr.len-1 -> ret: len-1
		-target index inside arr -> left of target 
		
	-IMP- its easier to get corner cases right away before doing loop.
        // If last element is smaller than x
        if (x >= arr[r])
            return r;
		if(x <arr[0])
			return -1;
		
		-now run template1 or 2 , either is ok
		
Celining:
	-template 2

			
7. DFS
continue from:
	TODO: hards
	
to remember:
	m_basic-calculator-ii.java -> 
		-maintain prev num and prev sign, because calculation/decision happens after getting next num. for num we need to see prev sign, for sign we need to know prev num.
		-little not intuitive. keep putting + and - operands (nums created so far) in stack. * and / calculate in run time.
		=>Addition (+) or Subtraction (-): We must evaluate the expression later based on the next operation. So, we must store the currentNumber to be used later. Let's push the currentNumber in the Stack.
		=>Multiplication (*) or Division (/): Pop the top values from the stack and evaluate the current expression. Push the evaluated value back to the stack.
		-buffer currentNum AND last sign seen (because after sign, we need RHS to evaluate expression. so when we are after RHS(whcih is next sign or end of string) ,we evaluate last sign )
		-if char is digit, keep forming currentNumber 
		-if char is not digit, and its not space, -> operate. and reset currentNumber = 0 at end
		-we are not forming final result in iteration, we keep putting each result back in stack . at the end, we iterate over stack and add them all 
		
	m_copy-list-with-random-pointer.java 
		-> need to use HashMap<origNode,newNode> as visited record, instead of set, because we need to retrieve new node to reuse (from given visited node)
	
	m_decode-string.java 
		-maintain 2 stacks, one for nums , one for string 
		-> when encounter [, we need to push stringSoFar on stack -> because there can be multiple/nested layers (just like num/count nesting), we we wont be able to store it directly in final result
		->k[string k[string k[string]
		-when see ], calculate string (suing both stack pop vals)
		-at the end result with be last string formed
	
	m_exclusive-time-of-functions.java -> see as time intervals. Since its logs, its already in chronological order/sorted, so no need to sort by start time. -> now imp to realize use of stack. We dont use PQ here like interval problems (because already sorted by start time). push started tasks in stack (like actual call stack !) -> stack<taskId> only. calculate exclusive time during iteration itself.
		-> when see end log, pop.
		->result can be array and taskId serves as index. so no hashmap required
		->when end log comes, taskid will alway match to top of stack. ()
	m_flatten-nested-list-iterator.java 
		-> imp to realize the recursive nature. since its rec, we can use stack. BUT we want them in FIFO order, so push items to stack with reverse loop on list given
		-> during constructore, put curernt list as is on stack (no deep flattening, that will be done while hasNext call)
		-> hasNext - if item is list, reuse the "insert" method, to flatten/insert that list on stack (just 1 list)
			-while(!st.isEmpty()) { //flatten each elem of curr stack , BUT if we see int , we stop} //we have to do this till st is empty, because there is possibility of nested lists without seeing any int. also list can be empty 
			
		->next - just pop item.
		-> imp: next will not be called without calling hsNext
	
		-->Queue based iterative solution:
		--> but downside is, we create new storage for entire nestedList again, rather that going thru given input.

	m_lesson_all-paths-from-source-to-target.java -> realize that we need to backtrack (remove curr neighbor from path) before next iteration to other neighbor. (after recursive dfs call)
Note: dfs helper function normally will not return anything, its just dfs sweeper. result will be recorded in some class var.

	m_lesson_path-sum-iii.java -> see each root to leaf path as array, and we are looking for subarray that sums to target. for that we use "prefix-sum" technique. so thats what we will do.
		-> imp : consider two nodes having same num (also -ve nums are allowed), so our prefix sum map will need <sumSoFar, frequency>
	
	
	m_word-search.java -> dfs+backtracking -> again exhaustive dfs. whenever there is exhaustive dfs, dont forget to clear/backtrack visited node if word not found here. if the path does not lead to a solution, we then revert the change (i.e. backtracking) and try another path.
		-> also this dfs helper needs to return boolena for whether word found or not. -> so need to OR all dfs directions.
		-> time complexity: Time Complexity: O(N. 3^L) where N is the number of cells in the board and L is the length of the word to be matched.
	
	https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
		-use DP , single dp[][] across all points/cells call  
		-fill dp with dfs 
		
8. Strings 
continue from:
	m_trick_multiply-strings
	
to remember:
	e_lesson_most-common-word.java -> good practice of string iteration by chars, and corner cases. -> character.isLetter and stringbuilder are enough to make word. we dont need start and end pointer to make word.
		how do we iterate char by char and derive each word?
		a. use two ptrs -> start and end
		b. use stringbuilder, build it up to one word, usinng just one ptr. after loop - check if strinbuilder is non empty (when whole string is 1 word or also for last word)
		
	longest-common-prefix - > there are many ways to solve. ->pick 1st string, and compare char by char in rest of strings. stop when dont match and return prefix.
		-> divide and conquer, binary search are possible.
		-> find min and max strings, then compare..
		
	reorder-data-in-log-files.java -> use String x = a.substring(a.indexOf(' ')+1,a.length());		
		-> also note: comparator for pq -> strA.compareTo(strB)
		PriorityQueue<String> pq = new PriorityQueue<>(
            (a,b)->{
                String x = a.substring(a.indexOf(' ')+1,a.length());
                String y = b.substring(b.indexOf(' ')+1,b.length());
                if(x.equals(y)){
                    return a.substring(0,a.indexOf(' ')).compareTo(b.substring(0,b.indexOf(' ')));//let1 vs let2
                } else 
                    return x.compareTo(y); 
        });
		
	reverse-words-in-a-string-iii -> how do we iterate char by char and derive each word?
		a. use two ptrs -> start and end -> in place operations. no extra space needed.
		b. use stringbuilder, build it up to one word, usinng just one ptr. - after loop - check if strinbuilder is non empty (when whole string is 1 word or also for last word)
	
	e_strstr.java -> brute force match at every char position in bigger string.
	
	e_trick-greatest-common-divisor-of-strings.java -> GCD for string is the biggest common substring. so we need to keep cutting substrings from begin point until we cant.
		-> if s1(bigger) string is empty(ultimately by recursive call), other is the answer to return.
		if (!str1.startsWith(str2)) {	//we use startsWith method instead of indexOf method. because If MUST start with s2 for it to be gcd
                return ""; 
		
		
	e_unique-email-addresse -> to replace occurences of . in string:  id = id.replaceAll("\\.","");   //remember this utility and \\ for before .
	
	m_atoi.java -> there are corner cases to be covered:
		0. remove spaces from front and back - trim
		1. sign in front - may or may not be present
		2. Integer overflow min and max. Store temp result on "long". if temp result = max or min, return max of min, because its overflow.
		3. look for non digit chars. once encounter, break/stop
		-> use long to store intermediate result to check int overflow. converting string to int, char/digit by digit. 
	
	m_group-shifted-strings ->
		-Consider acf and pru. Now notice the differnce between each characters.
			acf = 0->2->3, and pru = 0->2->3. So these two form same group. So in this case, you can simply use integers ASCII difference to form key.

			Now consider corner case, az and ba, where az = 0->25 and ba = 0->-1. When it goes negative, just make it positive(rotate or mod equivalent) by adding 26. So it becomes, ba = 0->25, which forms same group.
				a's next is b, and z's next is a

		key += String.format("%2d", (s.charAt(i) - s.charAt(i-1) + 26) % 26);//positive Difference from the previous char.
		->circular shifted strs in same group
		->TODO need to understand the logic ((a-z)+26)%26 -> %26 so that we get circular position. +26 because we want +ve num in case of "az"
		
	m_lesson_compare-version-numbers.java -> 
		-need to consider various corner cases: Following are equal:
			1.0 and 1.000
			1.0 and 1.0.0
			1.01 and 1.001
		->split string by dots
		->create utility to convert string to int. ->skip prefix zeros
		-key to make soln easy-for diff length, we can use 0 for whichever finished. ===> IMP TRICK FOR ANY 2 ARR OPERATIONS
		-the just compare seg1 and seg2, if diff return +-1 or after loop, they are euqal and return 0
		
	m_lesson_longest-substring-with-at-most-two-distinct-characters.java 
		-> need to store HashMap<char, latestIndex> -> we store latest/last index because, if we were to remove that char, we need to remove till right most occurence of that char. we cannot just remove left most char and be sure that that char is not present in window anuymore. eg abcccbdddddd
		
		-> only use of left ptr is to cal len of substring. not for remove char from left side.
		-> but leftmost cant be tracked with ptr, each time need to go over map and find leftMost char to remove from sliding window
		->when window/map size ==3, FIND THE LEFTMOST CHAR/INDEX TO BE REMOVED, BY GOING THEU MAP VALUES or just call Collections.min(map.values);
		-> note: it is possible to solve with lft and right ptrs and slide from left one by one and map<char,freq>, but not as straight as above.
		
	m_lesson_partition-labels.java ->
		it sounds complicated, recursive and dp problem, but its not !
		->2 pass solution:
        -Record the last occurence of each letter in map
        -Second pass can be done in way that we will get max partitions.
			-Keep current interval window marked by begin and end pointers
            -keeptrack of furthest most index of occurence for any letter in current interval/window. that var is our "end" ptr of window
            -if that is = i, we dont have anymore repeating in future, so partition window ends here. add it to result.
                Note: We END it here rather than including more unique chars because we want as many unique intervals as we can.
	
	m_longest-substring-without-repeating-characters.java 
		-> set is enough with sliding window. map not required here.
		-> when we slide from left, we dont increment the right ptr. because duplicate might just be right -1 ! eg: abcdee -> when we sit at right = 2nd e.
			-we slide from left till there is no duplicate in window.
			
	m_palindromic-substrings.java -> 
		-count palindrom from odd center. (i)
		-count palindrom from even center. (i,i+1)
			-to cehck palindrome, run loop to expand from center.
		-do this for every i from 0 to len 
	
	m_reverseWords.java
		->trim both ends first 
		->now reverse the string then reverse each word. 
		-> wo do this to avoid extra space. if we dont reverse, we will store each word in array/stack. ->then build string with words in reverse order.
	
	m_trick_fraction-to-recurring-decimal.java
		-explained well by diagram in leetcode.
		-> main trick : if remainder starts repeating, we know its repeating and finish
		-> we need to know where the repeating part starts. index of each digit in fraction -> do it by hashMap<Long, index>
		-> we use Long for all calculations to cover int overflows 
		-> how do we keep reducing remainder? -> this is just plain division operation.
			long remainder = dividend % divisor;
			-> while(ramainder ! = 0){
				ramainder *= 10; --> whi mult by 10? that is how we proceed manunal division
				remainder %= divisor;
			}

	https://github.com/krutikpatel/leetcode2019/blob/master/strings/m_trick_multiply-strings.java
		-> compute products from each pair of digits from num1 and num2. 
		-> carry each element over. (arr will have nums 1 to 99 possible)
		-> output the solution.

	https://leetcode.com/problems/minimum-window-substring/
		-normal tendency: 2 maps , matchcount from 0 to pattern len 
		-imp: pattern can have duplicate chars, so, matchcount != pattern.len 
			-matchcount = patternMap.size 
		
		-https://leetcode.com/problems/minimum-window-substring/discuss/26810/Java-solution.-using-two-pointers-%2B-HashMap
			-single hashmap 
			-count from t.len to 0 (t.len is ok if used correctly, we dont have to use tmap.len)
		OR go with this soln:
		https://designgurus.org/path-player?courseid=grokking-the-coding-interview&unit=grokking-the-coding-interview_1628541068682_8Unit
		
		
9. Priority Queue - Interval types
Note:
if we need top -k elem 
	-we can do it with PQ size of k+1
	-for max, make min heap. add k+1 elems. if (pq size >k)->poll top elem.
		-this will end up in top k elems in pq.
		
todo:
	lesson_car-pooling.java
	task-scheduler.java
	
to remember:
	m_exclusive-time-of-functions.java 
		-> see as time intervals. Since its logs, its already in chronological order/sorted, so no need to sort by start time using PQ. 
		-> now imp to realize use of stack. We dont use PQ here like interval problems (because already sorted by start time). 
		->push started tasks in stack (like actual call stack !) 
			-> maintain stack<taskId> only. calculate exclusive time during iteration itself. use lastStartedTime to track prev start-timestamp
			-> when see end log, pop.
			->result can be array and taskId serves as index. so no hashmap required
			->when end log comes, taskid will alway match to top of stack. (first to end will be last to start - because its single threaded - V Imp - this is why we are able to use stack only)
	
	m_interval-list-intersections.java 
		->iterate with ptrs over both arrays together
		->overlap interval = [biggerStart,smallerEnd]
			->then which ptr to move ?
			move minEnd - thats the one which ends first, because other one might still intersect with next
		->since we are looking for overlap - nothing to do after loop exits
	
	m_meeting-rooms-ii.java
		->first sort intervals by start time.
		->use pq to store intervals - sort by end time - min heap - so we get roo first to finish.
			-actually we are only using end time from intervals in pq. so we only need pq<Integer>
		->if new start-time >= end-time from pq, re-use room
			->remove this pq top interval - room can be reused.
		->add new interval to pq.

	merge-intervals.java
		->sort them by start time 
		->iterate and merge
			->while its possible to add loop inside to merge till we can with curr elem. since we are not doing it in place - not modifying given array, returning new arr, we wont do it. 
			->thats not good idea, complicates loop
			->just merge one at a time. while keeping track of prev interval.
		[what if there were 2 lists to merge?]
		
	reorganize-string.java
		->map chars by count.
		->store int[charASCII, count] in pq -> max heap
		->now keep polling pq and interleave.
			->poll one, append in stringBuilder, reduce its count 
			->that is now prev
			-> use prev to keep track of char we just used in result in last iteration. -> because we need to add it back to pq if count >0
			aab 
				1->remove a from pq 
				2->next time remove b, 
				-> prev is a. put back in pq.
				->add b in result -> ab -> then prev becomes b 
				3->prev = b but count == 0, so dont add in pq.
					->add a to result -> aba 
			->so, if (pq is empty && prev count > 0	) -> eg: aaab
				->then we can find elems/char to separate all "a". so return false 
		
		-given pq: aaaabbn
			think what wud u do. remove a, then use b, then  use a again
			
	merge-k-sorted-lists.java
		->add 1st elem of all lists to pq (min sorted)
		->now link nodes to create new ordered/merged list
		->now till pq is empty
			->poll, 
			->make linkage -> curr.next = polled -> curr = curr.next 
			->add curr's/polled's list's next elem to pq (if non null ie, list has not ended)

	car-pooling https://github.com/krutikpatel/leetcode2019/blob/master/priority_queue/lesson_car-pooling.java
		probably better to look at non pq based solutions..
		-sort arr by start time.
		-treat start and end time as intervals 
			-start point = capacity+
			-end point = capacity-
		-we will maintain pq - sorted by end time.
		->when we see end time 
		
10. Graph 
notes under graph directory.
	-https://leetcode.com/problems/evaluate-division/
		-As one can see, we just transform the problem into a path searching problem in a graph.
		** More precisely, we can reinterpret the problem as "given two nodes, we are asked to check if there exists a path between them. If so, we should return the cumulative products along the path as the result. **
		-Imagine a/b = k as a link between node a and b, the weight from a to b is k, the reverse link is 1/k. Query is to find a path between two nodes.
		-for each node, we need neighbors and weight of that edge. Best way to do that is Map<neightboer,weigth> for each node
		-adj list with weights : Map<String, Map<String, Double>> adj
		-need to track visited nodes in DFS to catch loop. 
		-return -1 for no sol and loops.
		IMP break conds:
			-if from is not in adj or to is not in adj map -> fail return -1
			-if visited in adj, we r in loop -> return -1 
			-no backtracking involved (in visited set, we just go from, from -> to in 1 call, we do not begin with other start point)
			
	-https://leetcode.com/problems/all-paths-from-source-to-target/
		-DFS + backtrack
		-all paths means backtrack
		-it is given that graph is "acyclic" - so we dont need to maintain "visited" map 
		
continue from:
todo:
	-Hard ones
	
11. Sliding window:
	-tip: implement with HashMap<char,int> rather than directly using int[] as map 
	-tip/note: lot of sliding window probs possoble to solve with single map as well. but complicated.
	-tip/note:
		-2 options to run loop 
			a. with i=0 to len 
			b. 2 ptrs. left and right. while(r<len)

to remember:
	->https://designgurus.org/path-player?courseid=grokking-the-coding-interview&unit=grokking-the-coding-interview_1628541055153_6Unit	
		-we dont have to worry about consecutiveness of window for pattern anagram/permutation
		-the matchCharCount combined with checking at each char, will take care of it.
		-so, just store <char,count> map for pattern, and decrement,increment it as we slide char by char.

	https://leetcode.com/problems/find-all-anagrams-in-a-string
	-sliding window 
	-tip: implement with HashMap<char,int> rather than directly using int[] as map 
	-solution dilemma in sliding window:
		-to build 1st window and then run the loop or
		-run loop while building 1st window? -> not that hard, can do this.
			//1. add char to wmap
			if(i>=patternLen){
				//2. check for equalness
				pmap.equals(wmap)
				
				//3
				//slide wmap from leftside
			}

			

12. Backtracking/recursion
-starting from leetcode 

	https://leetcode.com/problems/restore-ip-addresses/
		-maintain beginIndex and segmentCount - to return once done 
		-each time - we create segment with 1,2 or 3 digits and make recursive calls.
		-imp - the segment has to be valid(0 to 255), so validate before recursive call.
		-remove dot from last segment end.
	
	https://leetcode.com/problems/n-queens-ii/
		-how to mark/access diags \ and / to see if its valid?
		boolean[] d1,d2 //len 2*n 
		int id1 = col - row + n;    // this is / diagonal for that point. col -row can be negative, so if we want to store it in array, 
                                        // we have to make it +ve offset by adding n to each
        int id2 = col + row;        // this is \ diagonal for that point
        OR-use Set<Integer>
			and
			int currDiagonal = row - col;
            int currAntiDiagonal = row + col;			
	
		-generic formula to detect presence of other elem on that diagonal/antidiag. we are not just talking abt 2 diags, but 2diags for any point x,y
	
	-sudoku
	
		-recursive method params are not fancy, just board
		private boolean solve(char[][] board){
			-all param looping inside method.
			for rows 
				for cols 
					for num1to 9
		-isValid method for puttin num at particular cell 
			-validity for that 3x3 block
			int rr = 3 * (row/3);
			int cc = 3 * (col/3);
	
	https://leetcode.com/problems/remove-invalid-parentheses/
		-BFS:
		-Since optimal soluion is asked, we should think of BFS.
			-meaning : parallelly explore removing one parantheses from each position, and keep doing that at each level
			-strings resulting by removing one paranthesis from each positions, becomes my neoghbors for next level BFS
		-maintain Set of visited strings 
			// generate all possible states, as next BFS level
			for (int i = 0; i < s.length(); i++) {
			  // ignore non-paranthesis chars
			  if (s.charAt(i) != '(' && s.charAt(i) != ')') continue;
			
			  String t = s.substring(0, i) + s.substring(i + 1);
			
			  if (!visited.contains(t)) {
				// for each state, if it's not visited, add it to the queue
				queue.add(t);
				visited.add(t);
			  }
			}
		-trick for validity : 
			if ( count++
			if ) count--
			if(count <0) -> invalid/false
		-no need to worry about char inbetween. parantheses validity will be same regardless of chars between them.
		
		DFS: TODO
		-count invalid open and close braces.
		-Construct string from bottom up, dfs, using those counters.
			-
		
	https://leetcode.com/problems/word-break-ii/ ---------- V IMP to understand - recursion and DP - add to recursion and dp lists 
		-https://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS
		-we dont have to go char by char from given string and do recursion. rather,
		start from word in give dict arr, and see if give string "starts with" that word.
			-if so, make recursive call from there.
			-after return, add 1st word in front of return list to form answer string 
		
		(see in comment section in above link: its still easy to go char by char, we dont have to pass charIndex in recursive call.)

		Algo:
		-solve bruteforce for better understanding. 
			-char by char, form work and lookup in dict.
			-recursively cann for substring i-to-end 
			
		-DP- brute force DFS is slow, So we need to memoize.
			-what to memo? - if we have answer for given (prefix) string 
			HashMap<String, List<String> answers>
			
			-Here also 2 approaches
			a. recursively solveing postfix substring (i-to-end) is slower
			b. rather than looking up dict match for substring from begin-to-i, look for substring i-to-end
				-and recursively solve for substring 0-to-i
				-add sublist strings + " "+postfix word 
			
todo:
	
//	https://leetcode.com/problems/remove-invalid-parentheses/
		-DFS+trie
		-need of trie comes from the fact that we need to know that we have a prefix match so that we can keep continue down this route. otherwise waste of runtime.
		
	word-search 2
	word ladder 2
		
continue from:
	
	
Note:
-MIMP: think recursive prob as solving subproblem. eg: 
	-Permutation: abc -> a + permutations of (bc)
	-subset: abc -> a + subsets of (bc)
	-so we solve subproblem first, as a result output will be in that order.
	-combinaitions of 1,2,3,4 -> take 1 (add 1 to sofar) and solve problem recursively from 2
	
-permutations output order for swap based recursive algo
	Input: nums = [1,2,3]
	Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
	
-duplicates: 
	-the first call at any level is i=beginIndex: so we need to allow i=beginIndex but avoid duplicates.
		so: if(i!=beginIndex && twoNumsAreStillsame)
	-we normally sort entries so that duplicates are together. we might get away without sorting for permutation because of swap, but for subsets we need to.

-subsets output order will be:
	Input: nums = [1,2,2]
	Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
	if(soFar.size() > 0){
		ret.add(new ArrayList(soFar));//we make new cipy of list to add in result because this copy will keep modifying.
	}

-https://leetcode.com/problems/word-search/solution/
	-combintion of DFS and backtracking - super problem.
	-backtracking is during each DFS for visited nodes.
	-NOTE: visited boolean[][] does not have to be created fresh for every DFS starting point x,y. since we are backtracking and clearing flags, same map can be reused as is dugin next x,y DFS check.


13. DP
Note:
Notice how we construct the solution from using the previous solutions (previous values in array). 
This is in essence Dynamic Programming where you remember the previous computed values and make calculations faster.
	-ie, if we have 2 ptrs , normally we will 
		-soln(i) = derived from solj( 0 to i) --> because we already know solution of probs till "i", and we began i from 0.

IMP: dp state vars: diceIndex, sumSoFar NOT k, k is CONSTANT ! see which args are changing, those are state vars for dp memo 

Note:
	-all Palindrome question involves start and end index. dp and brute force recursion, iteration.

-Palindrome problems: 
	boolean[][] dp for substring problems -storing is subproblem palindrome 
	int[][] dp , for subsequence problems - storing len 
	
continue from:
	https://github.com/krutikpatel/leetcode2019/blob/master/dynamic_programming/m_minimum-path-sum.java
--	
	https://github.com/krutikpatel/leetcode2019/blob/master/dynamic_programming/e_best-time-to-buy-and-sell-stock.java
		-track minSoFar
		-if currElem > minSofar
			-track max diff/profit
	
	https://github.com/krutikpatel/leetcode2019/blob/master/dynamic_programming/e_maximum-subarray.java
		-simpler than the instinct of making it complicated. -no recursion no complicated memo.
		-its like sliding window problem acctually - But its not totally
		-this is a popular problem that can be solved using an algorithm called Kadane's Algorithm.
		-The difficult part of this problem is figuring out when a negative number is "worth" keeping in a subarray.
			-We need a general way to figure out when a part of the array is worth keeping.
			-any subarray whose sum is positive is worth keeping.
		-Ans: we don't actually need to build the subarray, we can just keep an integer variable current_subarray and add the values of each element there. When it becomes negative, we reset it to 0 (an empty array).
			-track max 
			-keep adding till sum is +ve 
			-if it becomes -ve, discard all. 
					if(sumSoFar < 0) {
						sumSoFar = nums[i];
					} else {
						sumSoFar = sumSoFar+nums[i];
					}
					maxSum = Math.max(maxSum, sumSoFar); 
			
		-Same thing can also be stated as:	
			currentSubarraySum = Math.max(num, currentSubarraySum + num);
		
	https://leetcode.com/problems/decode-ways/
		-good to think recursively as an exercise but, iterative is faster and not bad 
		-iterative:
			-at each index, form 2 nums, 1char and 2char
			-if they are valid, use them.
			-1char = 0 is invalid 
			->what should be begin index? 0 or 1? start with 1. we can use dp[0] as known base case.
	
		-recursive 
			-get the known good and bad case out of way 
			-if charAt(begin) == 0 -> return false/0
			-if only one char left, return 1
			-now: ret = way1 + way2 
				-way1 - use one char, ie next = begin+1
				-way2 - use 2 chars, ie next = begin+2
			
	https://github.com/krutikpatel/leetcode2019/blob/master/dynamic_programming/m_maximum-product-subarray.java
		-no dp required 
		-single pass, maintain min and max sofar. 
		

	https://leetcode.com/problems/knight-dialer/submissions/
		-first  understand problem correctly.
		-for any solution, we need to try all start points on num pad, 0 to 9
			-for each start point, make path of n nodes, each node is valid move neighbor 
		-precompute/populate neighbor/adj for each digit 
		-DFS 
			-in DFS helper call, see 2 params of call, and memo soln based on them.
	
	
	https://leetcode.com/problems/longest-increasing-subsequence
		-dont need to think recursively to derive ierative soln.
		-iterative soln with 2 ptrs for subsequence bound 
		-dp[] only we dont need 2d memo 
		
		Notice how we construct the solution from using the previous solutions (previous values in array). 
		This is in essence Dynamic Programming where you remember the previous computed values and make calculations faster.
			-ie, if we have 2 ptrs , normally we will 
				-soln(i) = derived from solj( 0 to i) --> because we already know solution of probs till "i", and we began i from 0.

		-we start from left side or 0 in array, BECAUSE we are lookinf for increasing subsequences. for palindrome like probs it wud not matter.
	
	https://leetcode.com/problems/valid-palindrome-iii
		-at most k removals 
		-is longest palindrome subsequnce length >= n-k? we have solved the longest palindromic subseq problem 
		
14. Design
continue from:
	min stack
	
-sorted done probs by freq on LC 
	-https://leetcode.com/problems/lru-cache/
		-HashMap as store Map<key,DllNode>, plus DoublyLinkedList nodes -> for ordering elem by access order.
		-DLL - head and tail refs
		
	https://leetcode.com/problems/time-based-key-value-store
		understand prob with example:
		foo:
			bar,1
			bar2,3
			abc,5
			
		get(foo,2) -> bar
		fet(foo,4) -> bar2

		Use:
			HashMap<key,List<Pair>>	
			-create simple pair class: time, val store
			
		get:
			-binary-search for ts -track smaller val
		IMP:
			-todo binary search - we need sorted list. since these are timestamps, we can assume its time sorted.

	https://leetcode.com/problems/insert-delete-getrandom-o1/
		-implement all : insert(val), remove(val) and getRandom() in O(1) time 
		-insert and remove kind of easy with basic hashMap 
		-getRandom : NEEDS index to randomize access.
			-index is only for array/lists 
			-arrayList is good, flexible size, indexed access and its list 
			=>remove can be problem in arrayList 
				-but, we can use trick: swap elem x with end, and remove end elem !
			
		-so, use: 
		1. ArrayList for storing vals 
		2. HashMap<val, itsIndexInList> for O(1) access
		
	https://leetcode.com/problems/logger-rate-limiter/solution/
		-simple approach:
			-use arr[10] as circular buf and set of size 10 to store strings at each timestamp 
			-slow 
		
		-HashMap<String, timeInt> - faster , O(1) runtime and O(n) storage.
			-if msg in map - need to check time and update tim 
			-if not in map, print it and record time 
	
	https://leetcode.com/problems/design-tic-tac-toe/
		-how to manage O(1) for move? -finding out if player won ?
		IMP: it is given that move i,j will be made on empty space. so we dont have to check if that cell is occupied.
		first instinct: store info for each row and col, 2 diags 
		But:
			-to check that row-x is won, we just need "sum" of each elems in that row, and not need to stroe whole row.
			-same for col and 2 diags 
			->how to represent 2 players?
				-both cant be done using +ve nums 
				-for player 1, use +1 and for pl2, -1
			
			->state can also be maintained as StringBuilder, choose chars for 1 and 2 
		
		-update diag: row==col 
		-update antidiag: row+col == n-1 
		 
========
TODO:
quick sort and related probs	

Java useful calls
====================
map: putIfAbsent instead of getOrDefault


============================================================
New Done probs:
============================================================
https://leetcode.com/problems/search-insert-position/
https://leetcode.com/problems/palindrome-linked-list/
	-way1
		-put all elems in arr/arrList and check if palindrome 
	-way2 -O(1) space, asked by FB
		-find mid of list (slow and fast ptr technique - run loop till both slow and fast != null)
			-mid is END OF 1st HALF, not start of 2nd half.
		-reverse 2nd half in place (-begin with prev = null, and restick links while curr != null)
		-compare 1st half and 2nd half, one by one 
	-way3
		-find mid 
		-use stack to store 1st half 
		-compare one by one with other half 
	-way4
		-recursive and its O(n) space in call stack though 
		
https://leetcode.com/problems/longest-consecutive-sequence/
	graph and BFS way - 2O(n)
	-One way of looking at this is as a graph traversal problem in which there are multiple disconnected subgraphs and we need identify the largest sub-graph.
    -A node 'num' is directly connected to its neighbours 'num-1' and 'num+1' if present in the array.
    -So basically we first prepare an adjacency list 'map' while iterating through all the array elements.
        //partial adj list, one node can help u get +-1 , and that node will lead u to its +-1
    -Now we do a BFS for each sub-graph and find out its size. If it's greater than 'max', we update max.
    -While doing BFS, we keep track of global visited node to avoid running into cycles.
    -Finally we return 'max'

	TODO - O(n) hashmap way 
		-Map(num, seqLen)
		for each n, check map for n-1 and n+1 -> then update those entries as well with len 
		len = 1 + leftLen + rightLen 
		
		-update farthest entries
			map.put(n - leftLen, sum);        
			map.put(n + rightLen, sum);//update farthest entries
                
                //following does not work!
                //map.put(n - 1, sum);
                //map.put(n + 1, sum);

https://leetcode.com/problems/palindrome-partitioning/
	-normal way is recursion+backtracking 
	-recursion helper method with begin/start ptr , maintain list of curr_palindrome_substrings 
	-loop from "start" till str.len to try all subtrings for palindrome 
	-if palindrome, then only make recursive call 
	-backtrack by removing last added palindrome from curr_palindrome_substrings
	
	-DP way TODO 
		-memo the isPalindrome part, memo[start][end]
		
https://leetcode.com/problems/sort-list/solution/
	-solve recursively using merger sort
	-get mid, ==>somewhat tricky: we need mid as a 1st node of 2nd half . Also, we need to cut the list at mid. ie, slow.next = null 
	-recursive call left = sort(head) , right = sort(mid)
	-now merge both using merge method - like problem - merge 2 sorted LL

https://leetcode.com/problems/rotate-array/submissions/
	-classic exercise to calculate rotated index 
	newIndex = (i+k) % n , n = len of arr 
		-works for both when i+k is smaller or bigger than n 
	TODO - in place method - not hard 	

https://leetcode.com/problems/maximal-square/
	-realize its DP problem, from matric[][] pattern 
	-brute force it little tricky although looks simple 
	-classic DP problem, like the dp[][] matrix we make for string based probs
    -note 1st col and 1 row remains as is, for base case
	  // dp(i, j) represents the length of the square 
      // whose lower-right corner is located at (i, j)
      // dp(i, j) = 1+ min{ dp(i-1, j-1), dp(i-1, j), dp(i, j-1) }	//min of all 3 neighbors (we are at bottom-right of square). if any nbr is 0, it will make curr as 1
	  
https://leetcode.com/problems/house-robber-iii/solution/
	https://leetcode.com/problems/house-robber-iii/discuss/79330/Step-by-step-tackling-of-the-problem
	
https://leetcode.com/problems/find-all-anagrams-in-a-string
	-sliding window 
	-tip: implement with HashMap<char,int> rather than directly using int[] as map 
	-solution dilemma in sliding window:
		-to build 1st window and then run the loop or
		-run loop while building 1st window? -> not that hard, can do this.
			//1. add char to wmap
			if(i>=patternLen-1){
				//2. check for equalness
				pmap.equals(wmap)
				
				//3
				//slide wmap from leftside
			}
	
	-tip/note: lot of sliding window probs possoble to solve with single map as well. but complicated.
	-tip/note:
		-2 options to run loop 
			a. with i=0 to len 
			b. 2 ptrs. left and right. while(r<len)

https://leetcode.com/problems/longest-increasing-subsequence/			

https://leetcode.com/problems/subarray-sums-divisible-by-k
	-trick to remember:
	2 nums who have num%k same ie, sum1%k == sum2%k, then sum2-sum1 is divisible by k 
	-find all such pairs.
	ans = pick 2 out of n pairs.
	-store such cound in array as hashmap 
	
	-trick2: if (remainder < 0) remainder += K; //Java has negative modulus so correct it. consider -ve nums 

https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
	-very good 
	TODO 
	
====================================
FB:
https://leetcode.com/problems/valid-word-abbreviation/submissions/
	-lesson - 
	-using for(char: abbr.chars) type loop, instead of maintaining index of abbr. that will add complexity 
	-after pattern/abbr loop finishes, we may or my not have reached solution still.
	-to pass, wordPtr MUST reach word.length (more than that or less both are invalid)
	
	-iterate thru abbr chars one by one
    -maintain wordPtr to track where we are in word
    -when count !=0 , we dont have to substring word for matching, just advance wp. and then match with next char
    -abbr chars index is moved by for loop, so wp++ has to be done by us
    -after loop exit: in order for success, wp+count HAS to be word.length, no less no more
    
	
https://leetcode.com/problems/valid-palindrome-ii/
	-use 2 ptr when want to remove char to skip char.
	-try simple iteration. use helper method for ispalindrome with 2 ptrs, l and r
		-keep advancing 2 ptrs till chars are equal
	-we dont need to maintain removedCharCounter, since only 1 char shud be removed.
		if (s.charAt(i) != s.charAt(j)) {
			return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);//just return reuslt of 1 char removal, 
		}
	-recursive solution is possible
		-dont mix iteration and recursion. make it pure recursion, for every char, u call recursion.
	OR:
	I think a good way for the (generic) followup may be using Longest Palindromic Subsequence.
	If the LPS has length >= n-k, then return true. O(n^2) algorithm.	

https://leetcode.com/problems/range-sum-of-bst
	-simple yet easy to get lost
	-Realize that its BST, and we ARE given RANGE. even if we visit every node once(like binary tree any prder traversal), we know range, so we can add it to sum accordingly.
	(Range sum in normal binary tree is easy too, if we are given range-low and high)
	-recursive is easy. maintain external sum var 
	-Easiest is:
		-just traverse like binary tree and if val is in range, add to sum.
		But to leverage BST prop 
	-see which side we need to go.
	-IMP to note that - sometimes we have to go both sides, sometimes only one side 
	so use if + if and NOT if,else 
	this: range 5,15 and 
		tree: 5 ->10 <-15
		tree: 5->10->15 (only left edge, 5 is at bottom)
		tree: 5<-10<-15 (only right edge, 5 is at top)
		
https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/
	-dont think recursively here (brute force recursion gives TLE anyways)
	-We can use stack to eliminate duplicates, just like recursion.
	for each c, if(c==s.peek())
			remove from stack (s.pop())
		else
			s.push(c)
	
	-actually we dont even need stack 
		-we can do same thing with maintaining stringBuilder as res and iterating over string char by char 
	-Algo:
	-maintain 1st and last ptr in string.
	-if both cahrs are same, remove last char 
	
https://leetcode.com/problems/simplify-path/
	-dont overcomplicate it by going char by char 
	-specially because there can be lot of combinations of paths. eg: /a/b/c/.././././//d
	
	-Just split string/path with '/'
		-and process each section 
	Following rules:
		-we need to skip .
		-by splitting with / we will have "" for // or more slashes, so ignore any "" section.
		-for .. , if we have prev dir on stack , remove it, otherwise ignore ..
		Thats it ! :)
		
https://leetcode.com/problems/binary-tree-vertical-order-traversal
	-https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/231140/Solved-Add-clarification-for-the-output-order
	problem breakdown:
	1st level of order : col sorted 
		-instead of any tricks to sort, just record min and max, so that we can iterate min to max col value ! ==> new trick learnt
	2nd: row sorted 
		-instead of any tricks to sort, just record min and max, so that we can iterate min to max row value !
		
	3rd: value sorted 

	->cols is x axis
	->rows is y axis
	Algo:
		-create class level map<col, map<row, PQ<nodeVals>>>
		-create DFS helper method, to fill this map. traverse tree and fill map.
			dfs(node, col, row)	//pass col, row +-1 accordingly 
		
		-in main method, form the ret list now.
		
	-we need to group elems by columns
	-ALSO, each column should be sorted top to bottom order 
	
	-columns wise grouping can be achieved by DFS (BFS as well) by keep tab of +-1 at each left/right move
	-vertical top-bottom order in each column - CAN be naturally achieved in BFS (without maintaining height param)- think level order traversal.
	So go by BFS (queue) rather than DFS (recursion)
	
	-with BFS, use Java's Pair class Pair<TreeNode, Integer> -int is column 
	make Queue of Pair<TreeNode, col>
	

https://leetcode.com/problems/nested-list-weight-sum - add to dfs
	-very good recursion exercise
	-pass depth param to recursive function 
	
https://leetcode.com/problems/diagonal-traverse/
	todo 
	-realize that even after switching direction/diagonal, we can run out of boundary on each 4 walls. also flipping is not always same, diff in top half and bottom half of rectangle 

https://leetcode.com/problems/continuous-subarray-sum
	-math magic 
	-sore sum,index - because we need atleast 2 elems in result. index will help with that 
	-we are asked for sum which is multiple of k 
	Logic:
		-if we can find any two subarray of prefix sum have same mod value, then their difference MUST be
			divisible by k. So we can use a map to store mod value of each prefix sum in map, with its index. Then check
		-store sum%k instead of sum 
		-map<sum%k,index>
		map.put(0, -1); //have to do it for 1st 2 elem sum
		
https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/
	-follow: https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/discuss/419443/Java-Clean-StringBuilder-solution
	Tricks learnt:
	1-to check validity of parantheses: - we dont need stack.
	-we just need one counter: open
		-if we see open: open++
		-if we see close: open--

	2. to find min para to remove:
		-maintain minCount
		-when we see invalid close: (ie, open <0)
			minCount++
		
		-at end:
			if open>0 : we have unmatched open , so add them to remove.
			minCount + open 

		
	-this problem does not need to compute minParan to 	remove.
	----
	Algo:
	-A valid pair of parentheses is consist of an open and a close. The open has to be before the close.
		-So, we can remove the extra close parenthese then remove extra open parenthese

	-Step1: the fist iteration, we remove the unwanted )
		-go chars : 0 to len 
		-maintain sb, skip invalid closing braces 
	-Step2: the second iteration, we remove the unwanted (
		-go chars: len to 0 ==> and because of this, dont forget to reverse the sb after loop.
		-skip(skip add to sb2), the open parantheses = numUnmatchedOpenBraces from prev loop.
	-think eg: ))((
			-1st loop will remove )) 
			-2nd loop will remove ((
			
	---
https://leetcode.com/problems/remove-invalid-parentheses
	-Solvable by BFS, and easy to remember than DFS? 
	
	Followable DFS solution:
		https://leetcode.com/problems/remove-invalid-parentheses/discuss/75034/Easiest-9ms-Java-Solution
		-good for understanding of open close bracket counts and recursion calls
		
			public void dfs(String s, int i, Set<String> res, StringBuilder sb, int rmL, int rmR, int open)
				-last param is the balanceness of string we formed. with single counter, like mentioned in soln above.
				
	Another good way to keep track of sesparate invalid parans: -->single counter does not tell which one is imbalance. may be it does +ve or -ve
		int open=0, close=0;
        for(int i=0;i<s.length();i++) {
            char c = s.charAt(i);
            if(c=='(') {
                open++;
            } else if(c==')') {
                if(open==0) {
                    close++;
                } else {
                    open--;
                }
            }
        }
		
TODO: https://leetcode.com/problems/minimum-add-to-make-parentheses-valid
		
https://leetcode.com/problems/buildings-with-an-ocean-view
	-simple, track max coming from right side.
	-and record index of greater elems in new list, then return the reversed list.

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii
	-sounds simple. but can be little tricky to write CLEAN solution 
	-note: we dont need to precompute both paths 
		-root is not provided 
	
	-LCA is simple :
		-if we know one path(node to root). put all nodes in set 
		-go over other path (node to root) , and when you find/stop at common point  

IMP for LCA problems:
	-forming both paths is not good idea.
	-dont do that 

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii
	p or q can be null. not guaranteed to be in tree !
	-dont worry about figuring out path.
	-if p or q is not in tree, LCA is null. so we need to know if they are there.
	-single helper method can check for both. maintain global count or boolean for both
	-Also, if both are present, while traversing, we can also find LCA answer like : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ 
		-VIMP the getLca helper method:
		-first left and right calls  - Becasue we want exhaustive search so that we find both p and q , rather than just lca of them.
		-rest lca method is same as : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ 
		

https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
	IMP:
	-recursive very easy, yet forget and find it complicated.
	-1stof all, recursive one pass is possible, so remember that.
	
	
https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/
	-good dp practice, long not needed.
	-IMP: dp state vars: diceIndex, sumSoFar NOT k, k is CONSTANT ! see which args are changing, those are states	
	- Integer[][] dp = new Integer[n+1][target+1];//since 2nd dimension max is target: instead of sumsofar, we need to go from target to 0
		-we r not choosing sumsofar as 2nd dimension because, we cant upperbound it for dp array declaration.
		-both state var dimension same 
	
https://leetcode.com/problems/maximum-swap
	->start from left - so that we swap most sig digit 
    ->find biggest from its left - good way to do taht is use buckets fo digits. and start from 9to 0bucket.    bucket stores index, so we know we are on right side of our digit.
		->store index of digits in arr[10]

https://leetcode.com/problems/next-permutation
	-choice of loops and their index are very very imp
	-1,2,3 and 3,2,1 are corner cases 
	
https://leetcode.com/problems/k-closest-points-to-origin -> add to PQ 
	V imp lesson for topk problem:
    -maintain PQ of size K but in reverse order than asked. (if min asked, maintain max and vise versa)
    -for each elem:
        -add to pq
        -if(pq size > k)
            -remove from pq
            
    -this results in k elems in desired fashion(min or max)    
	
	
====
TODO: add to github:
https://leetcode.com/explore/interview/card/apple/344/array-and-strings/3116/
https://leetcode.com/problems/knight-dialer/submissions/ DP	
https://leetcode.com/problems/shortest-path-in-binary-matrix
https://leetcode.com/problems/k-closest-points-to-origin - pq 
https://leetcode.com/problems/top-k-frequent-words/ - pq 
https://leetcode.com/problems/unique-paths/ - dp, matrix 
91. Decode Ways - dp 
	https://leetcode.com/problems/unique-paths-ii/
	
https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
https://leetcode.com/problems/alien-dictionary
https://leetcode.com/problems/squares-of-a-sorted-array/
https://leetcode.com/problems/evaluate-reverse-polish-notation/ - stack good practice 
https://leetcode.com/problems/maximum-product-subarray/ - array 
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

===
To remember others from top list
--------------------------------
https://leetcode.com/problems/rotate-image/
https://leetcode.com/problems/spiral-matrix/
https://leetcode.com/problems/powx-n/
https://leetcode.com/problems/unique-paths/
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/


===
To solve:
https://leetcode.com/problems/binary-tree-longest-consecutive-sequence
https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/discuss/101510/Java-solution-Binary-Tree-Post-Order-Traversal
