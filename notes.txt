2021_lc_coding
===================
1st round progress:
Every topic sorted by difficulty: easy to hard

Topics to cover:
-------------------
1. Binary Tree 
2. Binary Search
3. Array
4. bfs and queue
5. dfs and stack
6. Graph, topological sort 
7. HashMap
8. Strings
9. LinkedList
10. Dynamic Programming (many arrays and string problems here)
11. backtracking, recursion
12. Priority Queue
13. Greedy - nice to have

Practice by technique
-----------------------
-Sliding window
-2 pointers
-fast and slow pointers 
-DP
-interval type problems 
-cyclic sort?
-modified binary search 
-top-k elements

===================
===================
===================

1. Binary tree : 
---------------------
Tree:
			1
		2		3
	4		5
Depth First Traversals: 
(a) Inorder (Left, Root, Right) : 4 2 5 1 3 
(b) Preorder (Root, Left, Right) : 1 2 4 5 3 
(c) Postorder (Left, Right, Root) : 4 5 2 3 1
	
to remember:
	-lesson_binary-tree-postorder-traversal.java	-> there are mutiple ways to iterate using stack. see which one suites me.
	-balanced binary tree - 
		-top-down -check each node is balanced with helper method of height. O(n^2)
		-botttom up O(N) - needs node to store info - whether its balanced or not. build up on that.
			-even without storing info - bottom up is O(n)
			-visit eaach node once - Post order - call both children first.
			-this O(n) method to look for heigh difference called once only. store result in class var OR propagate in ret val.
		-THERE IS SUBTLE DIFFERENE BETWEEN THESE TWO IMPLEMENTATIONS THAT I DID NOT UNDERSTAND YET
		-same technique is used here for O(n):
			https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/e_diameter-of-binary-tree.java
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/e_lesson_subtree-of-another-tree.java
		-checking at each node is O(n^2)
		-converting tree to string - but order matters
		IMP - order matters. inorder will not work.
		ONLY preorder will work. its node by node comarision from top.
		ALSO: we need to count null leafs in string too, to avoid wrong comparisions, which gives false true.
        -to avoid returning true for example 2 above
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_binary-search-tree-iterator.java
		-next returns min elem - thus its in order retrival
		-we can use stack to store in-order sequence
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_count-univalue-subtrees.java
		-check for corner case: before calling curr node as univalue 
			if(n.right !=null && n.right.val != n.val)
                return false;
            if(n.left !=null && n.left.val != n.val)
                return false;
		-no need to overcomlicate - one helper method traversal over whole tree is enough. no need to pass down n.val
 		-post order traversal/DFS - call l & r, then decide if parent is univalue.
		
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_find-duplicate-subtrees.java
		-convert tree in string (INCLUDING NULL NODES) 
		-only certain order will work - POST order 
		-ONLY add dplicate trees to result once
			-For people who are curious about why in-order doesn't work, here's a simple example:
			TreeA:
			0
			/
			0

			TreeB:
			0
			\
			0

			They both have same in-order serialization "#0#0#" if we just use "#" to represent null.

	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_flatten-binary-tree-to-linked-list.java
		TODO 
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_boundary-of-binary-tree.java
		-i think can be done with level order traversal.
		-store 1st in left and last in right lists.
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_inorder-successor-in-bst.java
		-successor will be right of x -> once u go right it can be n or n.left
		-keep going left and right as per BST, whenever go left (record n as return value first)
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_insufficient-nodes-in-root-to-leaf-paths.java
		-good one with regards to passing vals and returning node and making links
		-pass down sum sofar
		-if sum < target at leaf, return null 
		-if n.l and n.r both becomes null, return null. -delete this node.
	
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_kth-smallest-element-in-a-bst.java
		-in-order tarversal and counter k (incement/decrement happens in-order, on current node. so counting does not start til lwe reach left most) - we dont have to worry about reaching left most elem and then start counting exclusively. that is part of "in order" processing.
		-that needs helper method (and class var for result ). cant be done in-place otherwise.
		-recursive - if we dont want class var - pass arr [counter,retVal]
		-iterative using stack, recursive usual. 
		
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_lowest-common-ancestor-of-a-binary-tree.java
		-first thought comes is helper method to find 2 elems under given node 
		-BUT we dodnt need that extra FIND method O(n^2)
		-//if root is p or q, that is LCA
        if( root == p || root == q || root == null)
            return root;
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_lesson_most-frequent-subtree-sum.java
		-dont need to calculate sum at each node separately
		-traverse tree once and record sums in map. map<sum,count>
		-sum = left+right+curr
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_serialize-and-deserialize-binary-tree.java
		Ser:
		pre-roder, # for null and ',' as delimiter
		
		Deser:
		Queue + preorder resursion
		Use Queue<> for deser, put all nodes in Q and just recreate tree in Pre-order fashion
		-Use Queue as FIFO, because thats the order in which we want to remove elems from list
		-IMP thing is deser is done in recursive fashion, just like pre-order, and elem taken from Queue every time in FIFO order

		-serialie - tree to array/string 
			-DFS pre-order traversal suits prob - bcoz that will make deser job easy. need to put null indicator in string 
		-desrialize - split string with delimiter ',' to get array 
			-use Queue , insert array in Queue - to get FIFO order
			-remove them one by one and just link them recursively (pre-order recursion)
	-https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/h_binary-tree-maximum-path-sum.java
		-DFS/Post order traversal helps with O(n) path sum cal
		-imp to think which all paths are valid, and can possibly max . nodes can have -ve values 
		-maintain class level max 
		-helper: return currPathMaxSum - so that upper level can be max 
						-that is currPathMaxSum = n.val + Math.max(l,r);
				-for l and r, important to take 0 if return val is negative, so that currPath does not become less due to -ve children.
		
Continue from:
	102 Binary Tree Level Order Traversal
	and githun from:
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_tree/m_trim-a-binary-search-tree.java


2. Binary search : 
---------------------
To remember-redo-practice:

Continue from:
	1099	Two Sum Less Than K

3. Array:
----------------------
github

Continue from:m_set-matrix-zeroes.java
	[hard remaining]
TODO:
https://leetcode.com/problems/top-k-frequent-elements/ - add this to github
	
to remember:
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_daily-temperatures.java	-> stack the indices rather than temp vals, because we need index diff. -> start from end -> monotonic stack.
	
	4 sum:
		-For each elem [i], solve k-1 problem recursively, at k=2, solve 2sum problem
			-2sum loop/sweep shud not end as soon as we find pair, because we need to find ALL pairs to continue till (l<r)
		
		-Time complexity is O(N^(K-1)).
		-generalize as :
		private List<List<Integer>> kSum(int[] nums, int target, int k, int leftBegin)
		-run loop till it becomes 2 sum prob OR k=2
			-that k loop looks like :
			for (int i = left; i < len - (k - 1); i++) {
                //use current number to reduce ksum into k-1sum
				//arr[i] will be part of sol list
                List<List<Integer>> curr = kSum(nums, target - nums[i], k-1, i+1);
				=> then add arr[i] to each lists returned
				
		-duplicate check has to be done in 2 sum as well as other loop too 
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_3sum-closest.java
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_3sum-smaller.java
		-tricky - there is more than just counting at each 2 sum sweep.
		-at any given 2sum sweep : if(localsum<target)
			-we need to count all combinations keeping "low or l". 
			x,l,r
			x,l,r-1 
			x,l,r-2 etc
		-that will not be covered in next iteration. bcoz if localsum<target, we will move to l++
			
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_find-all-duplicates-in-an-array.java
		-nums are 1 to n -> convert that to index/bucket as arr[i]-1
		-every time we see num, we do x * -1
		-so if num seen only once, it will be -ve 
		-second loop can catch this 
		-use Math.abs while calculting index, because num can be -ve as done by us only 
		
	cherry pick algo:
	https://leetcode.com/problems/remove-duplicates-from-sorted-array/ - remember the basic trick, write ptr, read ptr. no need to run fast pointer all at once
		-write/good ptr. ptr to track index to unique elems. (slow, write location) => this of this ptr as if we had new empty array where we store desired elems for return. ptr in that array where we can write new elem.
		-iterator ptr (fast, read ptr)
		=>similar qns: (in place array operations - single iteration solutions)
			https://leetcode.com/problems/remove-element/
			https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
			
		-write ptr and iterator will diverge as we start seeing duplicates to be removed.
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sliding-window_grumpy-bookstore-owner.java
	
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sort-colors.java
		-ptr to color 0, at 0
		-ptr to color 2, at len-1
		-iterate over array using i => while(i<=p2)
		
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_subarray-sum-equals-k.java
		-Sliding window cannot be used, because array contains negative number
		-Its "prefix sum" problem.
		-Solution 1. Brute force. We just need two loops (i, j) and test if SUM[i, j] = k. Time complexity O(n^2), Space complexity O(1). 
		-Solution 2. From solution 1, we know the key to solve this problem is SUM[i, j]. 
			-we need faster way to find SUM[i, j]
			-So if we know SUM[0, i] and SUM[0, j], then we can easily get SUM[i, j]
				SUM[i, j] = SUM[0, i] - SUM[0, j]
			
		-since we are asked to count HOW many times we see the sum, we need to store the Map<sumseen_sofar, count>
		-keep recording sum so far in map.
			-if we have seen  ( SUM[0, i] - target ) -> add this to answer.
			
	m_set-matrix-zeroes 
		-A straight forward solution using O(mn) space is probably a bad idea. track 0 converted elems/visited elems. so that we dont consider them original 0s.
		-improvement: only track col and row nums which needs to be zeroed. PAss1: record these rows and cols. PAss2: zero down those rows and cols. 2*O(mn)
		- work on memory efficient soln
			-> use this soln: https://leetcode.com/problems/set-matrix-zeroes/discuss/26008/My-AC-java-O(1)-solution-(easy-to-read)
			-They are using the first row and column as a memory to keep track of all the 0's in the entire matrix.
			-only problem with that is : if 0th row or col is 0. - >becaues if so : if 0throw is 0, we need to make 0th col zero as well. as same for cols 
			-so use 2 more flags to indicate if fr or fc is zero.
			
	product-of-array-except-self -> need to do without division. -> realize that product except self = product(on left) + product (right)
		-> that can be achieved without creating extra arrays for left and right.
		->use same arr for both loops. and that will be our ans 
		->iterate left to right skiping sefl
		->iterate right to left skipping self. both times record res in same array. that will be ans
	
	m_interval-list-intersections
		-iterate over both together 
		-find out if there is intersection 
		-then decide which arr to proceed 
	
	m_prison-cells-after-n-days
		-in-place modification of arr not possible, coz we need orig values of cell till end.
		-so create new arr to store the result. create hlper method to do this and return new arr 
		Optimization:
		-there is possibility of cycles if we change values N times.
		-in that case we can store result in hashSet and see if we have seen this before. if so, dont continue N days loop. its cyclic 
		-record at which iteration we got cycle 
			if(hasCycle){
				N%=cycle;
				for(int i=0;i<N;i++){
					cells = nextDay(cells);
				}   
			}
	
	https://leetcode.com/problems/rectangle-area/
		-calc both rectangle areas (x2-x1) * (y2-y1)
		-find overlap points
			-find overlap points and apply formula like above 
	
	m_trick_gas_station
		-tricky yet simple algebra
		-we dont have to try each position exclusively, single iteration is enough 
		-gas[] - gas_available
		-cost[] -gas_needed ( cost or dist )
		-track gasAvailable after each node 
		-if gasAvailable  -ve, that node is not answer 
		-at end if gas_needed+gas_available > 0 we are in surplus and can make it.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/array/m_lesson_sliding-window_grumpy-bookstore-owner.java
		-sliding window technique !
		-count normal sum of whole array.
		-now slide window of sixe X (counting/adding 1's to satisfied custs)
		-now keep sliding till end, and recor max every time we slide 
		==> or just dont count sum in advance and do it?
			-count satisfied custs while iterating
			-keep track of max in window and keep sliding 
		
4. 	BFS and queue:

There are 2 aspects to BFS.
-some problems, first figure out which all nodes need bfs and add them in queue.
-some problems, just start with one node in queue as starting point.

-level order traversal.
-iterate thru all neighbors?

Continue from: https://leetcode.com/problems/perfect-squares/

to remember:
	https://leetcode.com/problems/evaluate-division/solution/
	https://leetcode.com/problems/the-maze/solution/
		-DFS is more natural here. But BFS has advantage of less heap space.
		-need to keep track of visited nodes 
		-for(4 directions) {
			newpos = roll()
			if(dfs(newPos))
				return true;
		}
		
		BFS
		-add start pt in Q
		-poll Q 
		-add to visited 
		-check if its dest
		for(4 dirs) {
			newpos = roll(dir);
			if(not visited newPos)
				Q.add(newpos)
				
		}
		
	https://leetcode.com/problems/rotting-oranges/
	-first need to cound good oranges, because its possible that whole sweep cannot reach all good oranges, so we need to return -1 in that case.
	-we dont need to store visited nodes.
	-i think because we already recorded all rotten oranges first.
		-we only add nodes to Q once, 
		1. initially
		2. when we convert them to rotten in loop 
	
5. HashMaps
Continue from: github
	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_insert-delete-getrandom-o1.java
to remember:
	-log rate limiter - study various approaches IMP
	https://leetcode.com/problems/next-greater-element-i/
	https://leetcode.com/problems/isomorphic-strings/
		-go char by char 
		-need 2 maps. a to b char mapping and b to a chars mapping. because both sides can break the mapping done earlier.
		-if entry does not exist add (a to b) and (b to a)
		-if either side map entries dont match - false.
		
	https://leetcode.com/problems/find-duplicate-subtrees/
		representation of tree(segment) can be in terms os String with all nodes in some order (post order here is must)
		-also include null nodes
		-ONLY add dplicate trees to result once
		-we use HashMap<String,Integer> , because we want to know how many times we have seen current path, so that we dont add it to result more than once
		-For people who are curious about why in-order doesn't work, here's a simple example:
			TreeA:
			0
			/
			0

			TreeB:
			0
			\
			0
			They both have same in-order serialization "#0#0#" if we just use "#" to represent null.

	https://github.com/krutikpatel/leetcode2019/blob/master/hashmap/m_group-shifted-strings.java --> key forming math
	https://leetcode.com/problems/time-based-key-value-store/		

6. Binary Search 
continue from:
	h_median-of-two-sorted-arrays.java
	-from : m_lesson_search-a-2d-matrix-ii.java
	
to remember:
	-Note: search in binary tree can be done iteratively. go left or right till reach null leaf 
	m_Search_for_a_Range.java 
		-> use template-1 (l<=r) and record target index each time. Sicne we are looking for exact match - template1 is suitable.
		- template 2 (l<r) has issues - might get into endless loop.
	
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/e_sqrtx.java
		-return closest decimal is perfect square is not available
		-use division to overcome overflow, instead of long. -> because truncation is allowed as per question.
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/e_valid-perfect-square.java - use long instead of division technique. because division will lead to false true. (2 = 5/2 - but its not perfect square)
		-imp to check if its perfect square at end of loop too.
		
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-first-and-last-position-of-element-in-sorted-array.java
		-dont use while(l<r) template - problem narrow downing the end
		-use while(l<=r) template 
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-k-closest-elements.java - template III mid+k widnow
		if(Math.abs(arr[mid]-x) > Math.abs(arr[mid+k]-x)){
		-we are comparing mid and mid+k to decide which side to go.
			
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_search-a-2d-matrix-ii.java - TODO binary search way. currently doing narrowing down method, beginning bottom left corner.
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_find-minimum-in-rotated-sorted-array.java
		-what to do if there are duplicates?
		-if(nums[mid]==nums[right])
			reight--;//to skip dups
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_search-in-rotated-sorted-array.java
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_kth-largest-element-in-an-array.java
		-use quick sorting. quick sort partition step gives small nums on left of pivot selected.
		-so turn kth largest prob into len-kth smallest elem. k2 = len-k
		-partition method is recursive till we find k2 elems in left partition
			-if l> r return IntMAX
			-for partition, maintain writePtr = l, 
			-after loop, swap one more time 
			-if nums left of pivot == k2 return that index. 
			-if nums left of pivot > k2 -> go left
			else go right 
	
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_floor-function-sorted-array.java
		--normal bianry search function : if val not found, it ends up at smaller closest !
		-so use template 1, and keep recording val if its <x, at end of loop that will be our answer.
		-template 2 also popssible

todo:
	h_median-of-two-sorted-arrays.java	
	https://leetcode.com/problems/time-based-key-value-store/
	https://github.com/krutikpatel/leetcode2019/blob/master/binary_search/m_lesson_floor-function-sorted-array.java
		--normal bianry search function : if val not found, it ends up at smaller closest !
		-so use template 1, and return nums[start] after loop.
		-template 2 also popssible
	m_lesson_online-election.java
	
	
7. DFS
continue from:
	TODO: hards
	
to remember:
	m_basic-calculator-ii.java -> 
		-little not intuitive. keep putting + and - operands (nums created so far) in stack. * and / calculate in run time.
		=>Addition (+) or Subtraction (-): We must evaluate the expression later based on the next operation. So, we must store the currentNumber to be used later. Let's push the currentNumber in the Stack.
		=>Multiplication (*) or Division (/): Pop the top values from the stack and evaluate the current expression. Push the evaluated value back to the stack.
		-buffer currentNum AND last sign seen (because after sign, we need RHS to evaluate expression. so when we are after RHS(whcih is next sign or end of string) ,we evaluate last sign )
		-if char is digit, keep forming currentNumber 
		-if char is not digit, and its not space, -> operate. and reset currentNumber = 0 at end
		-we are not forming final result in iteration, we keep putting each result back in stack . at the end, we iterate over stack and add them all 
		
	m_copy-list-with-random-pointer.java 
		-> need to use HashMap<origNode,newNode> as visited record, instead of set, because we need to retrieve new node to reuse (from given visited node)
	
	m_decode-string.java 
		-maintain 2 stacks, one for nums , one for string 
		-> when encounter [, we need to push stringSoFar on stack -> because there can be multiple/nested layers (just like num/count nesting), we we wont be able to store it directly in final result
		->k[string k[string k[string]
		-when see ], calculate string (suing both stack pop vals)
		-at the end result with be last string formed
	
	m_exclusive-time-of-functions.java -> see as time intervals. Since its logs, its already in chronological order/sorted, so no need to sort by start time. -> now imp to realize use of stack. We dont use PQ here like interval problems (because already sorted by start time). push started tasks in stack (like actual call stack !) -> stack<taskId> only. calculate exclusive time during iteration itself.
		-> when see end log, pop.
		->result can be array and taskId serves as index. so no hashmap required
		->when end log comes, taskid will alway match to top of stack. ()
	m_flatten-nested-list-iterator.java 
		-> imp to realize the recursive nature. since its rec, we can use stack. BUT we want them in FIFO order, so push items to stack with reverse loop on list given
		-> during constructore, put curernt list as is on stack (no deep flattening, that will be done while hasNext call)
		-> hasNext - if item is list, reuse the "insert" method, to flatten/insert that list on stack (just 1 list)
			-while(!st.isEmpty()) { //flatten each elem of curr stack , BUT if we see int , we stop} //we have to do this till st is empty, because there is possibility of nested lists without seeing any int. also list can be empty 
			
		->next - just pop item.
		-> imp: next will not be called without calling hsNext
	
		-->Queue based iterative solution:
		--> but downside is, we create new storage for entire nestedList again, rather that going thru given input.

	m_lesson_all-paths-from-source-to-target.java -> realize that we need to backtrack (remove curr neighbor from path) before next iteration to other neighbor. (after recursive dfs call)
Note: dfs helper function normally will not return anything, its just dfs sweeper. result will be recorded in some class var.

	m_lesson_path-sum-iii.java -> see each root to leaf path as array, and we are looking for subarray that sums to target. for that we use "prefix-sum" technique. so thats what we will do.
		-> imp : consider two nodes having same num (also -ve nums are allowed), so our prefix sum map will need <sumSoFar, frequency>
	
	
	m_word-search.java -> dfs+backtracking -> again exhaustive dfs. whenever there is exhaustive dfs, dont forget to clear/backtrack visited node if word not found here. if the path does not lead to a solution, we then revert the change (i.e. backtracking) and try another path.
		-> also this dfs helper needs to return boolena for whether word found or not. -> so need to OR all dfs directions.
		-> time complexity: Time Complexity: O(N. 3^L) where N is the number of cells in the board and L is the length of the word to be matched.
	
	
8. Strings 
continue from:
	m_trick_multiply-strings
	
to remember:
	e_lesson_most-common-word.java -> good practice of string iteration by chars, and corner cases. -> character.isLetter and stringbuilder are enough to make word. we dont need start and end pointer to make word.
		how do we iterate char by char and derive each word?
		a. use two ptrs -> start and end
		b. use stringbuilder, build it up to one word, usinng just one ptr. after loop - check if strinbuilder is non empty (when whole string is 1 word or also for last word)
		
	longest-common-prefix - > there are many ways to solve. ->pick 1st string, and compare char by char in rest of strings. stop when dont match and return prefix.
		-> divide and conquer, binary search are possible.
		-> find min and max strings, then compare..
	reorder-data-in-log-files.java -> use String x = a.substring(a.indexOf(' ')+1,a.length());		
		-> also note: comparator for pq -> strA.compareTo(strB)
	reverse-words-in-a-string-iii -> how do we iterate char by char and derive each word?
		a. use two ptrs -> start and end -> in place operations. no extra space needed.
		b. use stringbuilder, build it up to one word, usinng just one ptr. - after loop - check if strinbuilder is non empty (when whole string is 1 word or also for last word)
	e_strstr.java -> brute force match at every char position in bigger string.
	e_trick-greatest-common-divisor-of-strings.java -> GCD for string is the biggest common substring. so we need to keep cutting substrings from begin point until we cant.
		-> if one string is empty, other is the answer to return.
	e_unique-email-addresse -> to replace occurences of . in string:  id = id.replaceAll("\\.","");   //remember this utility and \\ for before .
	m_atoi.java -> there are corner cases to be covered:
		0. remove spaces from front and back - trim
		1. sign in front - may or may not be present
		2. Integer overflow min and max. Store temp result on "long". if temp result = max or min, return max of min, because its overflow.
		3. look for non digit chars. once encounter, break/stop
		-> use long to store intermediate result to check int overflow. converting string to int, char/digit by digit. 
	m_group-shifted-strings ->
		key += String.format("%2d", (s.charAt(i) - s.charAt(i-1) + 26) % 26);//positive Difference from the previous char.
		->circular shifted strs in same group
		->TODO need to understand the logic ((a-z)+26)%26 -> %26 so that we get circular position. +26 because we want +ve num in case of "az"
		
	m_lesson_compare-version-numbers.java -> 
		-need to consider various corner cases: Following are equal:
			1.0 and 1.000
			1.0 and 1.0.0
			1.01 and 1.001
		->split string by dots
		->create utility to convert string to int. ->skip prefix zeros
		-key to make soln easy-for diff length, we can use 0 for whichever finished. ===> IMP TRICK FOR ANY 2 ARR OPERATIONS
	m_lesson_longest-substring-with-at-most-two-distinct-characters.java 
		-> need to store HashMap<char, latestIndex> -> we store latest/last index because, if we were to remove that char, we need to remove till right most occurence of that char. we cannot just remove left most char and be sure that that char is not present in window anuymore. eg abcccbdddddd
		
		-> only use of left ptr is to cal len of substring. not for remove char from left side.
		-> but leftmost cant be tracked with ptr, each time need to go over map and find leftMost char to remove from sliding window
		->when window/map size ==3, FIND THE LEFTMOST CHAR/INDEX TO BE REMOVED, BY GOING THEU MAP VALUES or just call Collections.min(map.values);
		-> note: it is possible to solve with lft and right ptrs and slide from left one by one and map<char,freq>, but not as straight as above.
	m_lesson_partition-labels.java ->
		it sounds complicated, recursive and dp problem, but its not !
		->2 pass solution:
        -Record the last occurence of each letter in map
        -Second pass can be done in way that we will get max partitions.
			-Keep current interval window marked by begin and end pointers
            -keeptrack of furthest most index of occurence for any letter in current interval/window. that var is our "end" ptr of window
            -if that is = i, we dont have anymore repeating in future, so partition window ends here. add it to result.
                Note: We END it here rather than including more unique chars because we want as many unique intervals as we can.
	m_longest-substring-without-repeating-characters.java 
		-> set is enough with sliding window. map not required here.
		-> when we slide from left, we dont increment the right ptr. because duplicate might just be right -1 ! eg: abcdee -> when we sit at right = 2nd e.
	m_palindromic-substrings.java -> 
		-count palindrom from odd center. (i)
		-count palindrom from even center. (i,i+1)
			-to cehck palindrome, run loop to expand from center.
		-do this for every i from 0 to len 
	m_reverseWords.java
		->trim both ends first 
		->now reverse the string then reverse each word. 
		-> wo do this to avoid extra space. if we dont reverse, we will store each word in array/stack. ->then build string with words in reverse order.
	m_trick_fraction-to-recurring-decimal.java
		-explained well by diagram in leetcode.
		-> main trick : if remainder starts repeating, we know its repeating and finish
		-> we need to know where the repeating part starts. index of each digit in fraction -> do it by hashMap<Long, index>
		-> we use Long for all calculations to cover int overflows 
		-> how do we keep reducing remainder? -> this is just plain division operation.
			long remainder = dividend % divisor;
			-> while(ramainder ! = 0){
				ramainder *= 10; --> whi mult by 10? that is how we proceed manunal division
				remainder %= divisor;
			}

	https://github.com/krutikpatel/leetcode2019/blob/master/strings/m_trick_multiply-strings.java
		-> compute products from each pair of digits from num1 and num2. 
		-> carry each element over. (arr will have nums 1 to 99 possible)
		-> output the solution.

9. Priority Queue - Interval types
Note:
if we need top -k elem 
	-we can do it with PQ size of k+1
	-for max, make min heap. add k+1 elems. if (pq size >k)->poll top elem.
		-this will end up in top k elems in pq.
		
todo:
	lesson_car-pooling.java
	task-scheduler.java
	
to remember:
	m_exclusive-time-of-functions.java 
		-> see as time intervals. Since its logs, its already in chronological order/sorted, so no need to sort by start time using PQ. 
		-> now imp to realize use of stack. We dont use PQ here like interval problems (because already sorted by start time). 
		->push started tasks in stack (like actual call stack !) 
			-> maintain stack<taskId> only. calculate exclusive time during iteration itself. use lastStartedTime to track prev start-timestamp
			-> when see end log, pop.
			->result can be array and taskId serves as index. so no hashmap required
			->when end log comes, taskid will alway match to top of stack. (first to end will be last to start - because its single threaded - V Imp - this is why we are able to use stack only)
	
	m_interval-list-intersections.java 
		->iterate with ptrs over both arrays together
		->overlap interval = [biggerStart,smallerEnd]
			->then which ptr to move ?
			move minEnd - thats the one which ends first, because other one might still intersect with next
		->since we are looking for overlap - nothing to do after loop exits
	
	m_meeting-rooms-ii.java
		->first sort intervals by start time.
		->use pq to store intervals - sort by end time - min heap - so we get roo first to finish.
			-actually we are only using end time from intervals in pq. so we only need pq<Integer>
		->if new start-time >= end-time from pq, re-use room
			->remove this pq top interval - room can be reused.
		->add new interval to pq.

	merge-intervals.java
		->sort them by start time 
		->iterate and merge
			->while its possible to add loop inside to merge till we can with curr elem. since we are not doing it in place - not modifying given array, returning new arr, we wont do it. 
			->thats not good idea, complicates loop
			->just merge one at a time. while keeping track of prev interval.
		[what if there were 2 lists to merge?]
		
	reorganize-string.java
		->map chars by count.
		->store int[charASCII, count] in pq -> max heap
		->now keep polling pq and interleave.
			->poll one, append in stringBuilder, reduce its count 
			->that is now prev
			-> use prev to keep track of char we just used in result in last iteration. -> because we need to add it back to pq if count >0
			aab 
				1->remove a from pq 
				2->next time remove b, 
				-> prev is a. put back in pq.
				->add b in result -> ab -> then prev becomes b 
				3->prev = b but count == 0, so dont add in pq.
					->add a to result -> aba 
			->so, if (pq is empty && prev count > 0	) -> eg: aaab
				->then we can find elems/char to separate all "a". so return false 
		
		-given pq: aaaabbn
			think what wud u do. remove a, then use b, then  use a again
			
	merge-k-sorted-lists.java
		->add 1st elem of all lists to pq (min sorted)
		->now link nodes to create new ordered/merged list
		->now till pq is empty
			->poll, 
			->make linkage -> curr.next = polled -> curr = curr.next 
			->add curr's/polled's list's next elem to pq (if non null ie, list has not ended)

10. Graph 
notes under graph directory.
	-https://leetcode.com/problems/evaluate-division/
		-As one can see, we just transform the problem into a path searching problem in a graph.
		** More precisely, we can reinterpret the problem as "given two nodes, we are asked to check if there exists a path between them. If so, we should return the cumulative products along the path as the result. **
		-Imagine a/b = k as a link between node a and b, the weight from a to b is k, the reverse link is 1/k. Query is to find a path between two nodes.
		-for each node, we need neighbors and weight of that edge. Best way to do that is Map<neightboer,weigth> for each node
		-adj list with weights : Map<String, Map<String, Double>> adj
		-need to track visited nodes in DFS to catch loop. 
		-return -1 for no sol and loops.
	
	-https://leetcode.com/problems/all-paths-from-source-to-target/
		-DFS + backtrack
		-all paths means backtrack
		-it is given that graph is "acyclic" - so we dont need to maintain "visited" map 
		
continue from:
todo:
	-Hard ones
	
11. Sliding window:

to remember:
	->https://designgurus.org/path-player?courseid=grokking-the-coding-interview&unit=grokking-the-coding-interview_1628541055153_6Unit	
		-we dont have to worry about consecutiveness of window for pattern anagram/permutation
		-the matchCharCount combined with checking at each char, will take care of it.
		-so, just store <char,count> map for pattern, and decrement,increment it as we slide char by char.
		

12. Backtracking/recursion
-starting from leetcode 

todo:
	https://leetcode.com/problems/restore-ip-addresses/
	n-queens
	https://leetcode.com/problems/remove-invalid-parentheses/
		-doable both DFS and BFS.
		-trick for validity : 
			if ( count++
			if ) count--
			if(count <0) -> invalid/false
		-no need to worry about char inbetween. parantheses validity will be same regardless of chars between them.
	
	https://leetcode.com/problems/remove-invalid-parentheses/
		-DFS+trie
		-need of trie comes from the fact that we need to know that we have a prefix match so that we can keep continue down this route. otherwise waste of runtime.
		
		
continue from:
	-sudoku solver
	
Note:
-MIMP: think recursive prob as solving subproblem. eg: 
	-Permutation: abc -> a + permutations of (bc)
	-subset: abc -> a + subsets of (bc)
	-so we solve subproblem first, as a result output will be in that order.

-permutations output order for swap based recursive algo
	Input: nums = [1,2,3]
	Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
	
-duplicates: 
	-the first call at any level is i=beginIndex: so we need to allow i=beginIndex but avoid duplicates.
		so: if(i!=beginIndex && twoNumsAreStillsame)
	-we normally sort entries so that duplicates are together. we might get away without sorting for permutation because of swap, but for subsets we need to.

-subsets output order will be:
	Input: nums = [1,2,2]
	Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
	if(soFar.size() > 0){
		ret.add(new ArrayList(soFar));//we make new cipy of list to add in result because this copy will keep modifying.
	}

-https://leetcode.com/problems/word-search/solution/
	-combintion of DFS and backtracking - super problem.
	-backtracking is during each DFS for visited nodes.
	-NOTE: visited boolean[][] does not have to be created fresh for every DFS starting point x,y. since we are backtracking and clearing flags, same map can be reused as is dugin next x,y DFS check.


========
TODO:
quick sort and related probs	

Java useful calls
====================
map: putIfAbsent instead of getOrDefault
