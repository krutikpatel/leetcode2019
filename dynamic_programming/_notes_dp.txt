==> Brute force solution most likely weill be recursive, atleast easier to derive in recursive way

==> Top-Down
-top-down ineherently means recursive if u think.
-then we can add memoisation to it to make it DP
-memo 2D/1D array will be 2or1 params that we pass to recursive funtion

==>Bottom-up
-since we build up solution its bottom-up and iterative
-start with sol(0) => this is something we know as base case, and use that to build up to sol(n)

==>Memo Array size 
-always [n][size/count/profit whatever param is + 1]
n is given array's length

==>time complexity for recursive calls:
if we make 2 calls is 2^n
because calling tree will have 2^n nodes


Knapsack/Subset problems
=============================
=============================
Fibonacci nums
=============================
=>Number Factors
	-n will never turn negative because of n-4 or n-3, because those factors are preemptively covered in base cases.
	-so base case will return val if n <3 or n<4
	-base cases: n=0,1,2,3 (4 not because it can be covered by others)

=>Min jumps to reach end of an array
	-brute force:
	-we just need to pass/use curr/begin index in recursive calls
	-MinJump result var does not have to be class var. can be declared in rec call, since top level call will ultimately return it.
	    // if we have reached the last index, we don't need any more jumps
	    if( currentIndex == jumps.length - 1)
	      return 0;//pass (callee will add res+1)

	    if (jumps[currentIndex] == 0)
	      return Integer.MAX_VALUE;// cannot make jump, so return some invalid val indicator
